#+TITLE: Airuta's Literate Config
#+AUTHOR: Mori Airuta
#+STARTUP: overview num

* INITIAL SETUP

User information.
#+begin_src emacs-lisp
(setq user-full-name "Mori Airuta"
      user-mail-address "mori.airuta@gmail.com")
#+end_src

Drive folder.
#+begin_src emacs-lisp
(setq drive-folder "~/Dropbox")
#+end_src

Auth setup.
#+begin_src emacs-lisp
(after! org-jira
  (setq auth-sources
        '((:source "~/.authinfo.gpg"))))
#+end_src

* UI & BEHAVIOR

Select a theme.
#+begin_src emacs-lisp
(setq doom-theme 'doom-tomorrow-day) ;; Other good themes: doom-one, doom-vibrant.
#+end_src

Define colors for todo keywords.
#+begin_src emacs-lisp
(setq todo-colors
      '(("TODO"      . (:foreground "#E6B168" :weight normal))
        ("NEXT"      . (:foreground "#ED6165" :weight normal))
        ("TDAY"      . (:foreground "#439EEA" :wegiht normal))
        ("WEEK"      . (:foreground "#998CD9" :wegiht normal))
        ("HOLD"      . (:foreground "#439EEA" :wegiht normal))
        ("WAIT"      . (:foreground "#998CD9" :wegiht normal))
        ("MAYBE"     . (:foreground "#998CD9" :wegiht normal))
        ("EXEC"      . (:foreground "#ED6165" :weight bold))
        ("DONE"      . (:foreground "#88B453" :weight normal))
        ("CANCEL"    . (:foreground "#666666" :weight normal))))
#+end_src

Font and line spacing.
#+begin_src emacs-lisp
(setq doom-font (font-spec :family "Lekton Nerd Font Mono" :size 14 :weight 'normal))
(setq-default line-spacing 0.4)
#+end_src

Set up line numbers.
#+begin_src emacs-lisp
(setq display-line-numbers-type t
      display-line-numbers-type 'relative)
#+end_src

Disable exit prompt.
#+begin_src emacs-lisp
(setq confirm-kill-emacs nil)
#+end_src

Setup modeline to make it look more terminal-like.
#+begin_src emacs-lisp
(setq doom-modeline-height 20
      doom-modeline-major-mode-color-icon nil
      doom-modeline-buffer-modification-icon nil
      doom-modeline-buffer-state-icon nil)
#+end_src

Define convenient window movement.
#+begin_src emacs-lisp
(map! :after evil
      ;; Navigation
      :n "H"   #'evil-window-left
      :n "J"   #'evil-window-down
      :n "K"   #'evil-window-up
      :n "L"   #'evil-window-right)
#+end_src

Disable mouse highlight. Why is it even enabled by default?
#+begin_src emacs-lisp
(setq mouse-highlight nil)
#+end_src

* MODULE SETUP

Set up which key delays.
#+begin_src emacs-lisp
(after! which-key
  (setq! which-key-idle-delay 0
         which-key-idle-secondary-delay 0))
#+end_src

Remove icons from treemacs.
#+begin_src emacs-lisp
(after! treemacs
  (setq treemacs-no-png-images t))
#+end_src

Set up projectile default path.
#+begin_src emacs-lisp
(after! projectile
  (setq projectile-project-search-path (list (concat drive-folder "/forge"))))
#+end_src

*** Evil

Set up evil-snipe.
#+begin_src emacs-lisp
(after! evil-snipe
  (setq evil-snipe-mode t
        evil-snipe-override-mode t))
#+end_src

* ORG MODE

Make property inheritance work.
#+begin_src emacs-lisp
(after! org
  (setq org-use-property-inheritance '("ORDERED" "SCHEDULED"))
  (load! "lisp/props"))
#+end_src

Replace boring org bullet with trigrams.
#+begin_src emacs-lisp
(use-package! org-superstar
  :config
  (add-hook 'org-mode-hook (lambda () (org-superstar-mode 1)))
  (setq org-superstar-headline-bullets-list '("☱" "☲" "☳" "☴" "☵" "☶" "☷")))
#+end_src

Prettify org mode a bit.
#+begin_src emacs-lisp
(after! org
  (setq org-ellipsis " ▾"))
#+end_src

** GTD

Basic definitions.
#+begin_src emacs-lisp
(setq ;; System locations
      org-directory          (concat drive-folder "/org")
      org-roam-directory     (concat org-directory "/roam")
      org-default-notes-file (concat org-roam-directory "/inbox.org")
      org-jira-working-dir   (concat org-roam-directory "/jira")
      org-roam-dailies-directory "daily/"
      ;; Files
      org-inbox-file         org-default-notes-file
      org-events-file        (concat org-directory "/events.org")
      org-habits-file        (concat org-directory "/habits.org")
      org-list-file          (concat org-directory "/list.org")
      ;; Dirs
      org-templates-dir      (concat org-roam-directory "/templates/")
      org-ledger-dir         (concat org-directory "/ledger/"))
#+end_src

Org mode todo items keywords.
#+begin_src emacs-lisp
(after! org
  (setq org-todo-keywords '((sequence "TODO(t)" "NEXT(n)" "HOLD(h)" "WAIT(w)" "MAYBE(m)" "EXEC(x)" "|" "DONE(d)" "CANCEL(c)"))
        org-todo-keyword-faces todo-colors
        org-enforce-todo-dependencies t))
#+end_src

Must-have tags, these should be settable from everywhere.
#+begin_src emacs-lisp
(setq org-tag-alist '(("@home"   . ?h)
                      ("@office" . ?o)
                      ("@errand" . ?e)
                      ("@comp"   . ?c)))
(setq! org-global-properties
       '(("Effort_ALL" . "0:05 0:10 0:15 0:30 0:45 1:00 2:00 4:00 8:00")))
#+end_src

Set up go-to keybindings.
#+begin_src emacs-lisp
(map! :prefix ("C-c f" . "files")
      :desc "inbox"    :m "x" (cmd! (find-file org-inbox-file))
      :desc "events"   :m "e" (cmd! (find-file org-events-file))
      :desc "habits"   :m "h" (cmd! (find-file org-habits-file))
      :desc "list"     :m "l" (cmd! (find-file org-list-file)))
#+end_src

Define some keys for convenience.
#+begin_src emacs-lisp
(map! :map org-mode-map
      :desc "prev-hl"    :m "C-k"   #'org-previous-visible-heading
      :desc "next-hl"    :m "C-j"   #'org-next-visible-heading
      :desc "store link" :m "C-c l" #'org-store-link
      :desc "execute"    :m "C-c x" (cmd! (ma/task-toggle))
      :desc "complete"   :m "C-c d" (cmd! (ma/task-done))
      :desc "hold"       :m "C-c h" (cmd! (ma/task-hold))
      :desc "wait"       :m "C-c w" (cmd! (ma/task-wait))
      :desc "schedule"   :m "C-c s" #'org-schedule
      :desc "deadline"   :m "C-c l" #'org-deadline
      :desc "tag"        :m "C-c t" #'org-ctrl-c-ctrl-c
      :desc "effort"     :m "C-c e" #'org-set-effort)
#+end_src

Prevent org-drill org-jira from handling their ids as node ids.
#+begin_src emacs-lisp
(defun ma/is-genuine-node (&optional pom create prefix)
  (org-with-point-at pom
    (and
     (not (org-entry-get nil "CUSTOM_ID"))
     (not (member "drill" (org-get-tags))))))

(require 'org-id)
(advice-add 'org-id-get :before-while 'ma/is-genuine-node)
#+end_src

*** Habits

Enable org-habit.
#+begin_src emacs-lisp
(setq org-log-into-drawer t
      org-habit-show-habits-only-for-today nil
      org-habit-show-all-today t
      org-habit-graph-column 40
      org-habit-following-days 3
      org-habit-preceding-days 7)

(after! org
  (add-to-list 'org-modules 'org-habit))
#+end_src
*** Drill

Set up org-drill.
#+begin_src emacs-lisp
(use-package! org-drill
  :after org
  :config
  (setq org-drill-hide-item-headings-p t
        org-drill-scope 'agenda))
#+end_src

*** Jira

Basic JIRA configuration.
#+begin_src emacs-lisp
(use-package! org-jira
  :config
  (setq jiralib-url "https://jira.north.io")
  (setq org-jira-default-jql "assignee = currentUser() and resolution = unresolved and project = DEV ORDER BY\n  priority DESC, created ASC"))
#+end_src

Main functionaliy: get issues and refile them into roam.
#+begin_src emacs-lisp
(defun org-jira--get-project-buffer (Issue)
  (with-slots (issue-id headline filename) Issue
    (let* ((org-roam-directory org-jira-working-dir)
           (issue-s (replace-regexp-in-string "-" "." issue-id))
           (title (format "issue.%s.%s" issue-s headline))
           (node (org-roam-node-create :title title))
           (base-name (org-roam-node-slug node))
           (file-name (concat base-name ".org"))
           (issue-template
            `(("i" "issue" plain "%?"
               :target (file+head ,file-name ,(ma/read-template "issue"))
               :immediate-finish t
               :unnarrowed t))))
      (oset Issue filename base-name) ; what an ugly hack!
      (org-roam-capture- :node node :templates issue-template)
      (org-roam-with-file (concat org-roam-directory "/" file-name) t
        (current-buffer))
    )))

(defun org-jira--render-issues-from-issue-list (Issues)
  (when (eq 0 (->> Issues (cl-remove-if-not #'org-jira-sdk-isa-issue?) length))
    (setq Issues (org-jira-sdk-create-issues-from-data-list Issues)))
  (setq Issues (cl-remove-if-not #'org-jira-sdk-isa-issue? Issues))
  (org-jira-log (format "About to render %d issues." (length Issues)))
  (mapc 'org-jira--render-issue Issues)
  (org-save-all-org-buffers)
  (org-roam-db-sync)
  (ma/refresh-agenda-files))
#+end_src

**** Keybindings

Redefine org-jira keybindings under C-c j prefix.
#+begin_src emacs-lisp
(map! :prefix ("C-c j" . "jira")
      :desc "refresh" :n "/" #'org-jira-get-issues)
#+end_src

*** Roam

Basic setup.
#+begin_src emacs-lisp
(after! org
  (setq +org-roam-open-buffer-on-find-file nil)) ;; Disable roam buffer when opening a new roam file
#+end_src

Helpers.
#+begin_src emacs-lisp
(defun ma/org-roam-node-category (node)
  (let ((props (org-roam-node-properties node)))
    (alist-get "CATEGORY" props nil nil #'equal)))

(defun ma/org-roam-filter-by-categories (categories)
  (lambda (node)
    (funcall #'or
           (mapcar (lambda (category) (equal category (ma/org-roam-node-category node)))
                   categories))))

(defun ma/org-roam-list-notes-by-categories (categories)
  (mapcar #'org-roam-node-file
          (seq-filter
           (ma/org-roam-filter-by-categories categories)
           (org-roam-node-list))))
#+end_src

Find file with category.
#+begin_src emacs-lisp
(defun ma/org-roam-find-by-category (category)
  (org-roam-node-find
   nil
   nil
   (lambda (node) (equal (ma/org-roam-node-category node) category))))
#+end_src

Refresh agenda files after a node with a tracker tag is created.
#+begin_src emacs-lisp
(defun ma/refresh-agenda-hook ()
  (when (org-roam-capture-p)
    (unless org-note-abort
      (when-let* ((id (org-roam-capture--get :id))
                  (node (org-roam-node-from-id id))
                  (category (ma/org-roam-node-category node)))
        (when (member category ma/org-roam-agenda-categories)
          (push (org-roam-node-file node) org-agenda-files))))))

(add-hook 'org-capture-after-finalize-hook #'ma/refresh-agenda-hook)
#+end_src

Immediate insertion.
#+begin_src emacs-lisp
(defun org-roam-node-insert-immediate (arg &rest args)
  (interactive "P")
  (let ((args (cons arg args))
        (org-roam-capture-templates (list (append (car org-roam-capture-templates)
                                                  '(:immediate-finish t)))))
    (apply #'org-roam-node-insert args)))

(map! :map org-mode-map
      :desc "insert" :g "C-c n I" #'org-roam-node-insert-immediate)
#+end_src

**** Capture

Helper function to read contents of a node template from file.
#+begin_src emacs-lisp
(defun ma/read-template (category)
  "Return the contents of FILENAME."
  (with-temp-buffer
    (insert-file-contents (concat org-templates-dir "/" category ".org"))
    (buffer-string)))
#+end_src

Capture with category.
#+begin_src emacs-lisp
(defun ma/org-roam-capture (key category entry target &optional GOTO)
  (let ((org-roam-capture-templates
        `((,key ,category 'plain
                ,entry
                :target ,target
                :unnarrowed t))))
    (org-roam-capture
     (when GOTO '(4))
     key
     :filter-fn (lambda (node) (equal (ma/org-roam-node-category node) category)))
    ))
#+end_src

Resource captures.
#+begin_src emacs-lisp
(defun ma/org-roam-capture-resource (key category &optional GOTO)
  (ma/org-roam-capture
   key
   category
   "* TODO %?"
   (list 'file+head
         (format "%s.${slug}.org" category)
         (ma/read-template category))
   GOTO))
#+end_src

Addendum note captures need special treatment.
#+begin_src emacs-lisp
(defun ma/org-roam-capture-addendum (key category file-format &optional GOTO)
  (let* ((head (ma/read-template category))
         (target (list 'file+head file-format head))
         (templates`((,key ,category 'plain "%?" :target ,target :unnarrowed t))))
    (org-roam-capture-
     :goto (when GOTO '(4))
     :keys key
     :node (org-roam-node-create)
     :templates templates
     :props (list :default-time (current-time)
                  :immediate-finish nil))
    (when GOTO (run-hooks 'org-roam-find-file-hook))))
#+end_src

Daily captures need special treatment.
#+begin_src emacs-lisp
(defun ma/org-roam-capture-daily-to-heading (key category entry file-format heading &optional GOTO FINISH)
  (let* ((org-roam-directory (expand-file-name org-roam-dailies-directory org-roam-directory))
         (head (ma/read-template category))
         (target (list 'file+head+olp file-format head (list heading)))
         (templates`((,key ,category 'entry "* %?" :target ,target :unnarrowed t))))
    (org-roam-capture-
     :goto (when GOTO '(4))
     :keys key
     :node (org-roam-node-create)
     :templates templates
     :props (list :override-default-time (current-time)
                  :immediate-finish FINISH))
    (when GOTO (run-hooks 'org-roam-dailies-find-file-hook))))

(defun ma/org-roam-capture-daily (entry heading &optional GOTO FINISH)
  (ma/org-roam-capture-daily-to-heading "d" "daily" entry "%<%Y.%m.%d>.org" heading GOTO FINISH))
#+end_src

Inbox capture.
#+begin_src emacs-lisp
(defun ma/capture-inbox ()
  (interactive)
  (let ((inbox-template
         '("x" "inbox" entry
           "* %?"
           :target (file+head "inbox.org" "#+TITLE: Inbox")
           :kill-buffer t
           :unnarrowed t)
         ))
  (org-roam-capture- :node (org-roam-node-create)
                     :templates (list inbox-template))))
#+end_src

**** Dendroam

Basic setup.
#+begin_src emacs-lisp
(use-package! dendroam
  :after org-roam)

(setq org-roam-node-display-template "${hierarchy}:${title}")
#+end_src

Fix dendroam.
#+begin_src emacs-lisp
(setq org-roam-slug-trim-chars '(;; Combining Diacritical Marks https://www.unicode.org/charts/PDF/U0300.pdf
                                   768 ; U+0300 COMBINING GRAVE ACCENT
                                   769 ; U+0301 COMBINING ACUTE ACCENT
                                   770 ; U+0302 COMBINING CIRCUMFLEX ACCENT
                                   771 ; U+0303 COMBINING TILDE
                                   772 ; U+0304 COMBINING MACRON
                                   774 ; U+0306 COMBINING BREVE
                                   775 ; U+0307 COMBINING DOT ABOVE
                                   776 ; U+0308 COMBINING DIAERESIS
                                   777 ; U+0309 COMBINING HOOK ABOVE
                                   778 ; U+030A COMBINING RING ABOVE
                                   780 ; U+030C COMBINING CARON
                                   795 ; U+031B COMBINING HORN
                                   803 ; U+0323 COMBINING DOT BELOW
                                   804 ; U+0324 COMBINING DIAERESIS BELOW
                                   805 ; U+0325 COMBINING RING BELOW
                                   807 ; U+0327 COMBINING CEDILLA
                                   813 ; U+032D COMBINING CIRCUMFLEX ACCENT BELOW
                                   814 ; U+032E COMBINING BREVE BELOW
                                   816 ; U+0330 COMBINING TILDE BELOW
                                   817 ; U+0331 COMBINING MACRON BELOW
                                   ))
#+end_src

**** Keybindings

Set up C-c n keybindings.
#+begin_src emacs-lisp
(map! :prefix ("C-c n" . "notes")
      :desc "refresh" :g "/" #'org-roam-db-sync
      :desc "toggle"  :g "t" #'org-roam-buffer-toggle
      :desc "find"    :g "f" #'org-roam-node-find
      :desc "insert"  :g "i" #'org-roam-node-insert
      :desc "capture" :g "c" #'org-roam-capture
      :desc "today"   :g "d" #'org-roam-dailies-goto-today)
#+end_src

Set up C-c c capture keybindings.
#+begin_src emacs-lisp
(map! :prefix ("C-c c" . "capture")
      :desc "inbox"   :g "x" #'ma/capture-inbox
      :desc "article" :g "a" (cmd! (ma/org-roam-capture-resource "a" "article" t))
      :desc "book"    :g "b" (cmd! (ma/org-roam-capture-resource "b" "book"    t))
      :desc "course"  :g "c" (cmd! (ma/org-roam-capture-resource "c" "course"  t))
      :desc "quote"   :g "q" (cmd! (ma/org-roam-capture-resource "q" "quote"   nil))
      :desc "project" :g "p" (cmd! (ma/org-roam-capture-resource "p" "project" t))
      :desc "zettel"  :g "z" (cmd! (ma/org-roam-capture-resource "z" "zettel"  t)))

(map! :map org-mode-map
      :prefix ("C-c c" . "capture")
      :desc "note"    :g "n" (cmd! (ma/org-roam-capture-addendum "n" "note" "${current-file}.note.%<%Y.%m.%d>.org" nil))
      :desc "meeting" :g "m" (cmd! (ma/org-roam-capture-addendum "m" "meeting" "${current-file}.meeting.%<%Y.%m.%d>.org" t))
      :desc "scratch" :g "s" (cmd! (ma/org-roam-capture-addendum "s" "scratch" "scratch.%<%Y.%m.%d.%M%S%3N>.org" t)))

(map!
      :prefix ("C-c c" . "capture")
      :desc "daily"   :g "d" (cmd! (ma/org-roam-capture-daily "%H:%M : %?" "Journal")))
#+end_src

Set up C-c f find node keybindings.
#+begin_src emacs-lisp
(map! :prefix "C-c f"
      :desc "task"    :m "t" (cmd! (ma/org-roam-find-by-category "daily"))
      :desc "article" :m "a" (cmd! (ma/org-roam-find-by-category "article"))
      :desc "book"    :m "b" (cmd! (ma/org-roam-find-by-category "book"))
      :desc "quote"   :m "q" (cmd! (ma/org-roam-find-by-category "quote"))
      :desc "course"  :m "c" (cmd! (ma/org-roam-find-by-category "course"))
      :desc "zettel"  :m "z" (cmd! (ma/org-roam-find-by-category "zettel"))
      :desc "issues"  :m "i" (cmd! (ma/org-roam-find-by-category "issue"))
      :desc "notes"   :m "n" (cmd! (ma/org-roam-find-by-category "note"))
      :desc "meeting" :m "m" (cmd! (ma/org-roam-find-by-category "meeting"))
      :desc "project" :m "p" (cmd! (ma/org-roam-find-by-category "project")))
#+end_src
*** Agenda

Set up org-agenda.
#+begin_src emacs-lisp
(defvar ma/org-roam-agenda-categories
  '("book" "course" "project" "note" "task"))

(defun ma/refresh-agenda-files ()
  (interactive)
  (setq org-agenda-files
        (append
         (list org-habits-file org-events-file org-list-file)
         (ma/org-roam-list-notes-by-categories ma/org-roam-agenda-categories))))

(after! org
  (ma/refresh-agenda-files)
  (setq org-agenda-start-day nil ; Today
        org-agenda-span 'day     ; Only one day in overview
        org-agenda-dim-blocked-tasks 'dimmed
        org-agenda-start-with-log-mode t
        org-agenda-time-grid `((daily today)
                               ,(mapcar (lambda (time) (* 100 time)) (number-sequence 0 24))
                               ""
                               "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")))
#+end_src

Because agenda API is so poor, i need to switch to task org file every time I want
to do anything complicated. This macro helps me automate the process.
#+begin_src emacs-lisp
(defmacro agenda-cmd! (&rest body)
  (declare (doc-string 1) (pure t) (side-effect-free t))
  `(lambda (&rest _)
     (interactive)
     (let* ((marker (or (org-get-at-bol 'org-marker) (org-agenda-error)))
            (pos (marker-position marker))
            (buffer (marker-buffer marker)))
       (org-with-remote-undo buffer
         (with-current-buffer buffer
           (goto-char pos)
           ,@body)))
     (org-agenda-redo)
     (org-save-all-org-buffers)))
#+end_src

**** Groups

Set up org-super-agenda.
#+begin_src emacs-lisp
(defun ma/get-task-prefix (level)
  "Returns task prefix for sue in hierarchical agenda."
  (let ((level (- (org-outline-level) (+ 1 level))))
    (if (> level 0)
        (format "%s-"
                (make-string (- (* 2 level) 1)
                             ?\s))
      "")))

(defun ma/skip-if-blocked ()
  (let ((next-headline (save-excursion
                         (or (outline-next-heading) (point-max)))))
    (if (org-entry-blocked-p) next-headline)))

(defun ma/agenda-project-name (item)
  (-when-let* ((marker (org-super-agenda--get-marker item))
               (file-name (->> marker marker-buffer buffer-name)))
    (concat "Project: " file-name)))

(defun ma/get-keyword-key-value (kwd)
  (let ((data (cadr kwd)))
    (list (plist-get data :key)
          (plist-get data :value))))

(defun ma/org-current-buffer-get-title ()
  (nth 1
       (assoc
        "TITLE"
        (org-element-map
            (org-element-parse-buffer 'greater-element)
            '(keyword)
          #'ma/get-keyword-key-value))))

(defun ma/org-file-get-title (file)
  (with-current-buffer (find-file-noselect file)
    (ma/org-current-buffer-get-title)))

(defun ma/agenda-title (item)
  (when-let ((marker (org-super-agenda--get-marker item)))
    (->> marker marker-buffer buffer-name ma/org-file-get-title)))

(defun ma/agenda-issue-name (item)
  (when-let ((title (ma/agenda-title item)))
    (concat "Issue: " title)))

(use-package! org-super-agenda
  :after org-agenda
  :init
  (setq org-agenda-custom-commands
        '( ;; A list of commands
          ("a" "Agenda view"
           ( ;; A list of sections
            (agenda "" ((org-agenda-overriding-header "")
                        (org-agenda-prefix-format "   %-20c :   %05e    :   %5t  ")
                        (org-agenda-time-grid nil)
                        (org-super-agenda-groups
                         '((:discard (:todo "DONE"))
                           (:name "Closed"
                            :log closed
                            :order 0)
                           (:name "Habits"
                            :habit t
                            :order 2)
                           (:name "Today"
                            :and (:todo "NEXT"
                                  :date today)
                            :order 1)
                            (:discard (:anything t))
                           ))))
            (alltodo "" ((org-agenda-overriding-header "")
                         (org-agenda-prefix-format "   %-20c :   %05e    :   %5t  ")
                         (org-agenda-time-grid nil)
                         (org-agenda-skip-function 'ma/skip-if-blocked)
                         (org-super-agenda-groups
                          '((:discard (:scheduled future))
                            (:discard (:habit t))
                            (:name "Executing"
                             :todo "EXEC"
                             :order 1)
                            (:name "Tasks"
                             :and (:todo "NEXT" :category "task")
                             :order 2)
                            (:name "Learning"
                             :and (:todo "NEXT" :category ("book" "course" "article"))
                             :order 3)
                            (:name "Issues"
                             :and (:todo "NEXT" :category "issue")
                             :order 4)
                            (:name "On hold"
                             :todo "HOLD"
                             :order 5)
                            (:name "Waiting"
                             :todo "WAIT"
                             :order 6)
                            (:name "Lists"
                             :category "list"
                             :order 7)
                            (:discard (:anything t))
                           ))))
            ))
          ("t" "Tasks view"
           ( ;; A list of sections
            (alltodo "" ((org-agenda-overriding-header "")
                         (org-agenda-prefix-format "   %-20c :   %05e    :   %5t  %(ma/get-task-prefix 1) ")
                         (org-agenda-time-grid nil)
                         (org-super-agenda-groups
                          '((:discard (:file-path "issue\\."))
                            (:discard (:file-path "project\\."))
                            (:discard (:todo "MAYBE"))
                            (:name "Tasks"
                             :category "task"
                             :order 1)
                            (:discard (:anything t))
                           ))))))
          ("p" "Projects view"
           ( ;; A list of sections
            (alltodo "" ((org-agenda-overriding-header "")
                         (org-agenda-prefix-format "   %-20c :   %05e    :   %5t  %(ma/get-task-prefix 1) ")
                         (org-agenda-time-grid nil)
                         (org-super-agenda-groups
                          '((:discard (:not (:file-path "project\\.")))
                            (:name "Project tasks"
                             :auto-map ma/agenda-project-name
                             :order 1)
                            (:discard (:anything t))
                           ))))))
          ("i" "Issues view"
           ( ;; A list of sections
            (alltodo "" ((org-agenda-overriding-header "")
                         (org-agenda-prefix-format "   %-20c :   %05e    :   %5t  %(ma/get-task-prefix 1) ")
                         (org-agenda-time-grid nil)
                         (org-super-agenda-groups
                          '((:discard (:not (:file-path "issue\\.")))
                            (:name "Issue tasks"
                             :auto-map ma/agenda-issue-name
                             :order 1)
                            (:discard (:anything t))
                           ))))))
          ("u" "Incubators"
           ( ;; A list of sections
            (alltodo "" ((org-agenda-overriding-header "")
                         (org-agenda-prefix-format "   %-20c :   %5t  ")
                         (org-agenda-time-grid nil)
                         (org-super-agenda-groups
                          '((:discard (:not (:todo "MAYBE")))
                            (:auto-tags t
                             :order 1)
                            (:discard (:anything t))
                           ))))))
          ("l" "Learning view"
           ( ;; A list of sections
            (alltodo "" ((org-agenda-overriding-header "")
                         (org-agenda-prefix-format "   %-20c :   %05e    :   %5t  %(ma/get-task-prefix 0) ")
                         (org-agenda-time-grid nil)
                         (org-super-agenda-groups
                          '((:discard (:not (:category ("article" "book" "course"))))
                            (:discard (:not (:todo ("TDAY" "WEEK" "NEXT"))))
                            (:name "Learning"
                             :auto-map ma/agenda-title
                             :order 2)
                            (:discard (:anything t))
                            ))))))
          ("n" "Notes view"
           ( ;; A list of sections
            (alltodo "" ((org-agenda-overriding-header "")
                         (org-agenda-prefix-format "   %-20c :   %5t  ")
                         (org-agenda-time-grid nil)
                         (org-super-agenda-groups
                          '((:name "Notes"
                             :and (:todo "TODO" :category "note")
                             :order 2)
                            (:discard (:anything t))
                            ))))))
          ("g" "Time grid view"
           ( ;; A list of sections
            (agenda "" ((org-agenda-overriding-header "")
                        (org-agenda-prefix-format "   %5t  ")
                        (org-super-agenda-groups
                         '((:discard (:habit t))
                           (:name "Today"
                            :time-grid t
                            :date today
                            :order 1)
                           (:discard (:anything t))
                           ))))))
          ))
  :config
  (org-super-agenda-mode t))
#+end_src

**** Keybindings

Set up keybindings.
#+begin_src emacs-lisp
(map! :after evil-org-agenda
      :map (org-agenda-mode-map evil-org-agenda-mode-map org-super-agenda-header-map)
      :desc "prev"     :g "k"     #'org-agenda-previous-line
      :desc "next"     :g "j"     #'org-agenda-next-line)

(map! :after org-agenda
      :map org-agenda-mode-map
      ;; Entry manipulation
      :desc "complete" :m "C-c d" (agenda-cmd! (ma/task-done))
      :desc "hold"     :m "C-c h" (agenda-cmd! (ma/task-hold))
      :desc "wait"     :m "C-c w" (agenda-cmd! (ma/task-wait))
      :desc "execute"  :m "C-c x" (agenda-cmd! (ma/task-toggle))
      :desc "schedule" :m "C-c s" (agenda-cmd! (org-schedule nil))
      :desc "deadline" :m "C-c l" (agenda-cmd! (org-deadline nil))
      :desc "tag"      :m "C-c t" (agenda-cmd! (org-ctrl-c-ctrl-c))
      :desc "effort"   :m "C-c e" (agenda-cmd! (org-set-effort))
      ;; Filtering
      :leader
      :prefix ("r a f" . "filter")
      :desc "by tag"    :m "t" #'org-agenda-filter-by-tag
      :desc "by effort" :m "e" #'org-agenda-filter-by-effort)

(map! :prefix ("C-c a" . "agenda")
      :desc "refresh"    :g "/"   #'ma/refresh-agenda-files
      :desc "agenda"     :g "a"   (cmd! (org-agenda nil "a"))
      :desc "tasks"      :g "t"   (cmd! (org-agenda nil "t"))
      :desc "incubators" :g "u"   (cmd! (org-agenda nil "u"))
      :desc "issues"     :g "i"   (cmd! (org-agenda nil "i"))
      :desc "projects"   :g "p"   (cmd! (org-agenda nil "p"))
      :desc "learning"   :g "l"   (cmd! (org-agenda nil "l"))
      :desc "notes"      :g "n"   (cmd! (org-agenda nil "n"))
      :desc "grid"       :g "g"   (cmd! (org-agenda nil "g")))
#+end_src

*** Refiling

Set up general refiling parameters.
#+begin_src emacs-lisp
(setq org-refile-use-outline-path 'file
      org-outline-path-complete-in-steps nil
      org-refile-allow-creating-parent-nodes 'confirm)
#+end_src

General refiling function provides a better interface than out-of-the-box org-refile.
#+begin_src emacs-lisp
(defun ma/refile (target heading &optional arg default-buffer msg)
  "Refile entries with top-level PARENT under the (exact) HEADING in FILE."
  (let* ((position
          (if heading
              (with-current-buffer (find-file-noselect target)
                (or (org-find-exact-headline-in-buffer heading)
                    (org-end-of-subtree t t)))))
         (rfloc `(,heading ,target nil ,position))
         (org-after-refile-insert-hook #'save-buffer))
    (org-refile arg default-buffer rfloc msg)))
#+end_src

Interactive refile to file.
#+begin_src emacs-lisp
(defun ma/refile-to-file (file state &optional follow)
  (interactive)
  (org-todo state)
  (org-entry-put (point) "ORDERED" "t")
  (ma/refile file nil)
  (when follow
    (org-refile-goto-last-stored)))
#+end_src

Refile a task to today's daily note.
#+begin_src emacs-lisp
(defun ma/refile-task (&optional state follow)
  (interactive)
  (let ((org-refile-keep nil) ;; Set this to t to keep the original
        (org-after-refile-insert-hook #'save-buffer)
        today-file
        pos)
    (save-window-excursion
      (ma/org-roam-capture-daily "* %?" "Tasks" t)
      (setq today-file (buffer-file-name))
      (setq pos (point)))
    ;; Only refile if the target file is different than the current file
    (unless (equal (file-truename today-file)
                   (file-truename (buffer-file-name)))
      (org-todo state)
      (org-entry-put (point) "ORDERED" "t")
      (org-refile nil nil (list "Tasks" today-file nil pos))
      (when follow
        (org-refile-goto-last-stored)))))
#+end_src

Refile to habits file. This functions adds formating to make an item into a habit.
#+begin_src emacs-lisp
(defun ma/refile-to-habits ()
  "Move the current subtree from processing to a habits."
  (interactive)
  (org-todo "TODO")
  (org-insert-property-drawer)
  (org-entry-put (point) "STYLE" "habit")
  (org-entry-put (point) "LAST_REPEAT" nil)
  (let* ((date (org-read-date))
         (min (read-number "Do the habit no often than this many days: " 1))
         (max (read-number "Do the habit at least once in this many days: " 1))
         (repeat-str
          (if (>= min max)
              (format ".+%dd" min)
              (format ".+%dd/%dd"))))
    (org-schedule nil (message "<%s %s>" date repeat-str))
    (ma/refile org-habits-file nil)))
#+end_src

**** Keybindings

Set up C-c keybindings.
#+begin_src emacs-lisp
(map! :map (org-mode-map org-agenda-mode-map)
      :prefix ("C-c r" . "refile")
      :desc "refile"     :n "/" #'org-refile
      :desc "task"       :n "t" (cmd! (ma/refile-task "NEXT"))
      :desc "event"      :n "e" (cmd! (ma/refile-to-file org-events-file "TODO"))
      :desc "habits"     :n "h" #'ma/refile-to-habits
      :desc "incubate"   :n "u" (cmd! (ma/refile-task "MAYBE")))
#+end_src

*** States

Defininig my (extremenly simple) state machine.
#+begin_src emacs-lisp
(defun ma/task-start (state)
  (when (member (org-get-todo-state) '("NEXT" "HOLD"))
    (org-todo state)
    (org-clock-in)))

(defun ma/task-stop (state)
  (when (equal (org-get-todo-state) "EXEC")
    (org-todo state)
    (org-clock-out nil t)))

(defun ma/task-done ()
  (org-todo "DONE"))

(defun ma/task-hold ()
  (org-todo "HOLD")
  (org-clock-out nil t))

(defun ma/task-wait ()
  (org-todo "WAIT"))

(defun ma/task-toggle ()
  (interactive)
  (let ((todo-state (org-get-todo-state)))
    (cond ((equal todo-state "NEXT") (ma/task-start "EXEC"))
          ((equal todo-state "HOLD") (ma/task-start "EXEC"))
          ((equal todo-state "EXEC") (ma/task-stop "NEXT")))))
#+end_src

Define helper functions.
#+begin_src emacs-lisp
(defun ma/is-top-level ()
  (equal (org-outline-level) 2)) ;; 2 because tasks live under Tasks heading

(defun ma/has-tag (tag)
  (member tag (org-get-tags)))
#+end_src

I want my hooks to run in specific files only. This macro will automate file name checking.
#+begin_src emacs-lisp
(defvar ma/todo-completion-category nil)

(defmacro todo-completion! (fn)
  "Run command only in buffer specified by `ma/todo-completion-category'."
  (declare (doc-string 1) (pure t) (side-effect-free t))
  `(lambda (&rest rest)
    (when (equal (org-get-category) ma/todo-completion-category)
      (interactive)
      (apply ,fn rest))))
#+end_src

I need a way to automatically make next item become "NEXT" when the current one changes to "DONE".
#+begin_src emacs-lisp
(defun ma/complete-and-continue ()
  "Switch current heading to DONE and next to NEXT."
  (interactive)
  (unless (ma/is-top-level)
    (when (save-excursion (outline-get-next-sibling))
      (org-forward-heading-same-level 1)
      (org-todo "NEXT"))))
#+end_src

I need to auto-done parents when all childrern are "DONE" or checked.
#+begin_src emacs-lisp
(defun ma/summary-todo (n-done n-not-done)
  "Switch entry to DONE when all subentries are done."
  (when (= n-not-done 0) (org-todo "DONE")))
#+end_src

I need to set the next sibling to "NEXT" when the current one is "DONE".
#+begin_src emacs-lisp
(defun ma/complete (change)
  (let ((from-state (plist-get change :from))
        (to-state (plist-get change :to)))
    (when (and (member from-state '("NEXT" "EXEC" "HOLD")) (equal to-state "DONE"))
      (unless (ma/is-top-level)
        (ma/complete-and-continue)))))
#+end_src

Use what I defined in the todo hooks.
#+begin_src emacs-lisp
(after! org
  (setq ma/todo-completion-category "task"))

(after! org
  (add-hook 'org-after-todo-statistics-hook (todo-completion! 'ma/summary-todo))
  (add-hook 'org-trigger-hook (todo-completion! 'ma/complete)))
#+end_src

*** Clocking

Clocking setup
#+begin_src emacs-lisp
(after! org
  (setq org-clock-out-when-done t))
#+end_src

Set up a hook to save clocked time to dailies
#+begin_src emacs-lisp
(defun ma/agenda-get-heading (&optional NO-TAGS NO-TODO NO-PRIORITY NO-COMMENT)
  (let* ((marker (or (org-get-at-bol 'org-marker) (org-agenda-error)))
         (pos (marker-position marker))
         (buffer (marker-buffer marker)))
    (with-current-buffer buffer
      (goto-char pos)
      (org-get-heading NO-TAGS NO-TODO NO-PRIORITY NO-COMMENT))))

(defun ma/clock-out-handler ()
  (let* ((start-time (format-time-string "%H:%M" org-clock-start-time))
         (end-time (format-time-string "%H:%M" org-clock-out-time))
         (heading (if (equal major-mode 'org-agenda-mode)
                      (ma/agenda-get-heading t t t t)
                    (org-get-heading t t t t)))
         (entry (format "** %s - %s : %s" start-time end-time heading)))
    (ma/org-roam-capture-daily entry "Journal" nil t)
    ))

(after! org-roam
  (add-hook 'org-clock-out-hook 'ma/clock-out-handler))
#+end_src
