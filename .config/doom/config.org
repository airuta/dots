#+TITLE: Airuta's Literate Config
#+AUTHOR: Mori Airuta
#+STARTUP: overview num

Set =lexical-binding= for this file.
#+begin_src emacs-lisp
;;; config.el -*- lexical-binding: t; -*-
#+end_src

* INITIAL SETUP

User information.
#+begin_src emacs-lisp
(setq user-full-name "Mori Airuta"
      user-mail-address "mori.airuta@gmail.com")
#+end_src

Drive folder.
#+begin_src emacs-lisp
(setq drive-folder "~/Dropbox")
#+end_src

Auth setup.
#+begin_src emacs-lisp
(after! org-jira
  (setq auth-sources
        '((:source "~/.authinfo.gpg"))))
#+end_src

* UI & BEHAVIOR

Select a theme.
#+begin_src emacs-lisp
(setq doom-theme 'doom-tomorrow-day) ;; Other good themes: doom-one, doom-vibrant.
(after! doom-themes
  :config
  (setq doom-themes-enable-bold nil))
#+end_src

Define colors for todo keywords.
#+begin_src emacs-lisp
(setq todo-colors
      '(("TODO"      . (:foreground "#E6B168" :weight normal))
        ("NEXT"      . (:foreground "#ED6165" :weight normal))
        ("ITER  "      . (:foreground "#ED6165" :weight normal))
        ("TDAY"      . (:foreground "#439EEA" :weight normal))
        ("WEEK"      . (:foreground "#998CD9" :weight normal))
        ("HOLD"      . (:foreground "#439EEA" :weight normal))
        ("WAIT"      . (:foreground "#998CD9" :weight normal))
        ("MAYBE"     . (:foreground "#998CD9" :weight normal))
        ("EXEC"      . (:foreground "#ED6165" :weight bold))
        ("DONE"      . (:foreground "#88B453" :weight normal))
        ("CANCEL"    . (:foreground "#666666" :weight normal))))
#+end_src

Font and line spacing.
#+begin_src emacs-lisp
(setq doom-font (font-spec :family "Lekton Nerd Font Mono" :size 14 :weight 'normal))
(setq-default line-spacing 0.4)
#+end_src

Set up line numbers.
#+begin_src emacs-lisp
(setq display-line-numbers-type t
      display-line-numbers-type 'relative)
#+end_src

Disable exit prompt.
#+begin_src emacs-lisp
(setq confirm-kill-emacs nil)
#+end_src

Setup modeline to make it look more terminal-like.
#+begin_src emacs-lisp
(setq doom-modeline-height 20
      doom-modeline-major-mode-color-icon nil
      doom-modeline-buffer-modification-icon nil
      doom-modeline-buffer-state-icon nil)
#+end_src

Define convenient window movement.
#+begin_src emacs-lisp
(map! :after evil
      ;; Navigation
      :n "H"   #'evil-window-left
      :n "J"   #'evil-window-down
      :n "K"   #'evil-window-up
      :n "L"   #'evil-window-right)
#+end_src

Disable mouse highlight. Why is it even enabled by default?
#+begin_src emacs-lisp
(setq mouse-highlight nil)
#+end_src

* MODULE SETUP

Set up which key delays.
#+begin_src emacs-lisp
(after! which-key
  (setq! which-key-idle-delay 0
         which-key-idle-secondary-delay 0))
#+end_src

Set up projectile default path.
#+begin_src emacs-lisp
(after! projectile
  (setq projectile-project-search-path (list (concat drive-folder "/forge"))))
#+end_src

*** Evil

Set up evil-snipe.
#+begin_src emacs-lisp
(after! evil-snipe
  (setq evil-snipe-mode t
        evil-snipe-override-mode t))
#+end_src

* ORG MODE

Make property inheritance work.
#+begin_src emacs-lisp
(after! org
  (setq org-use-property-inheritance '("ORDERED" "SCHEDULED"))
  (load! "lisp/props"))
#+end_src

Replace boring org bullet with trigrams.
#+begin_src emacs-lisp
(use-package! org-superstar
  :config
  (add-hook 'org-mode-hook (lambda () (org-superstar-mode 1)))
  (setq org-superstar-headline-bullets-list '("☱" "☲" "☳" "☴" "☵" "☶" "☷")))
#+end_src

Prettify org mode a bit.
#+begin_src emacs-lisp
(after! org
  (setq org-ellipsis " ▾"))
#+end_src

** GTD

Basic definitions.
#+begin_src emacs-lisp
(setq ;; System locations
      org-directory          (concat drive-folder "/org")
      org-roam-directory     (concat org-directory "/roam")
      org-default-notes-file (concat org-roam-directory "/inbox.org")
      org-jira-working-dir   (concat org-roam-directory "/jira")
      org-roam-dailies-directory "daily/"
      ;; Files
      org-inbox-file         org-default-notes-file
      org-events-file        (concat org-directory "/events.org")
      org-habits-file        (concat org-directory "/habits.org")
      org-list-file          (concat org-directory "/list.org")
      ;; Dirs
      org-templates-dir      (concat org-roam-directory "/templates/")
      org-ledger-dir         (concat org-directory "/ledger/"))
#+end_src

Org mode todo items keywords.
#+begin_src emacs-lisp
(after! org
  (setq org-todo-keywords '((sequence "TODO(t)" "NEXT(n)" "HOLD(h)" "WAIT(w)" "MAYBE(m)" "EXEC(x)" "|" "DONE(d)" "CANCEL(c)"))
        org-todo-keyword-faces todo-colors
        org-enforce-todo-dependencies t))
#+end_src

Must-have tags, these should be settable from everywhere.
#+begin_src emacs-lisp
(setq org-tag-alist '(("@home"    . ?h)
                      ("@office"  . ?o)
                      ("@errand"  . ?e)
                      ("@comp"    . ?c)
                      ("2read"    . ?r)
                      ("2watch"   . ?w)
                      ))
(setq! org-global-properties
       '(("Effort_ALL" . "0:05 0:10 0:15 0:30 0:45 1:00 2:00 4:00 8:00")))
#+end_src

Set up go-to keybindings.
#+begin_src emacs-lisp
(map! :prefix ("C-c f" . "files")
      :desc "inbox"    :m "x" (cmd! (find-file org-inbox-file))
      :desc "events"   :m "e" (cmd! (find-file org-events-file))
      :desc "habits"   :m "h" (cmd! (find-file org-habits-file))
      :desc "list"     :m "l" (cmd! (find-file org-list-file)))
#+end_src

Define some keys for convenience.
#+begin_src emacs-lisp
(map! :map org-mode-map
      :desc "prev-hl"    :m "C-k"   #'org-previous-visible-heading
      :desc "next-hl"    :m "C-j"   #'org-next-visible-heading
      :desc "store link" :m "C-c l" #'org-store-link
      :desc "execute"    :m "C-c x" (cmd! (ma/task-toggle))
      :desc "complete"   :m "C-c d" (cmd! (ma/task-done))
      :desc "hold"       :m "C-c h" (cmd! (ma/task-hold))
      :desc "wait"       :m "C-c w" (cmd! (ma/task-wait))
      :desc "schedule"   :m "C-c s" #'org-schedule
      :desc "deadline"   :m "C-c l" #'org-deadline
      :desc "tag"        :m "C-c t" #'org-ctrl-c-ctrl-c
      :desc "effort"     :m "C-c e" #'org-set-effort)
#+end_src

Prevent org-drill org-jira from handling their ids as node ids.
#+begin_src emacs-lisp
(defun ma/is-genuine-node (&optional pom create prefix)
  (org-with-point-at pom
    (and
     (not (org-entry-get nil "CUSTOM_ID"))
     (not (member "drill" (org-get-tags))))))

(require 'org-id)
(advice-add 'org-id-get :before-while 'ma/is-genuine-node)
#+end_src

*** Habits

Enable org-habit.
#+begin_src emacs-lisp
(setq org-log-into-drawer t
      org-habit-show-habits-only-for-today nil
      org-habit-show-all-today t
      org-habit-graph-column 40
      org-habit-following-days 3
      org-habit-preceding-days 7)

(after! org
  (add-to-list 'org-modules 'org-habit))
#+end_src

Sorting for habits. Morning habits always come first, evening habits come last. Habits
without time property come in between. Within one time setting, habits with order property
come earlier than habits without one.
#+begin_src emacs-lisp
(defun ma/org-get-time (entry)
  (let ((marker (org-super-agenda--get-marker entry)))
    (org-entry-get marker "TIME")))

(defun ma/org-get-order (entry)
  (let ((marker (org-super-agenda--get-marker entry)))
    (string-to-number
     (or (org-entry-get marker "ORDER") "999"))))

(defun ma/org-agenda-sort-habits (a b)
  "Sort habits first by user priority, then by schedule+deadline+consistency."
  (let ((ha (get-text-property 1 'org-habit-p a))
        (hb (get-text-property 1 'org-habit-p b)))
    (when (and ha hb)
      (let ((ta (ma/org-get-time a))
            (tb (ma/org-get-time b)))
        (cond ((equal ta tb) (ma/cmp-by-order a b))
              ((equal ta "morning") -1)
              ((equal tb "evening") -1)
              (t +1))))))

(defun ma/cmp-by-order (a b)
  (let ((oa (ma/org-get-order a))
        (ob (ma/org-get-order b)))
    (cond ((> oa ob) +1)
          ((< oa ob) -1)
          ((= oa ob) (ma/cmp-by-priority a b)))))

(defun ma/cmp-by-priority (a b)
  (let ((pa (org-get-priority a))
        (pb (org-get-priority b)))
    (cond ((> pa pb) +1)
          ((< pa pb) -1)
          ((= pa pb) (org-cmp-values a b 'priority)))))

(after! org
  (setq org-agenda-cmp-user-defined 'ma/org-agenda-sort-habits
        org-agenda-sorting-strategy '((agenda time-up user-defined-up habit-down)
                                      (todo priority-down category-keep)
                                      (tags priority-down category-keep)
                                      (search category-keep))))
#+end_src

*** Drill

Set up org-drill.
#+begin_src emacs-lisp
(use-package! org-drill
  :after org
  :config
  (setq org-drill-hide-item-headings-p t
        org-drill-scope 'agenda))
#+end_src

*** Jira

Basic JIRA configuration.
#+begin_src emacs-lisp
(use-package! org-jira
  :config
  (setq jiralib-url "https://jira.north.io")
  (setq org-jira-default-jql "assignee = currentUser() and resolution = unresolved and project = DEV ORDER BY\n  priority DESC, created ASC"))
#+end_src

Main functionaliy: get issues and refile them into roam.
#+begin_src emacs-lisp
(defun org-jira--get-project-buffer (Issue)
  (with-slots (issue-id headline filename) Issue
    (let* ((org-roam-directory org-jira-working-dir)
           (issue-s (replace-regexp-in-string "-" "." issue-id))
           (title (format "issue.%s.%s" issue-s headline))
           (node (org-roam-node-create :title title))
           (base-name (org-roam-node-slug node))
           (file-name (concat base-name ".org"))
           (issue-template
            `(("i" "issue" plain "%?"
               :target (file+head ,file-name ,(ma/read-template "issue"))
               :immediate-finish t
               :unnarrowed t))))
      (oset Issue filename base-name) ; what an ugly hack!
      (org-roam-capture- :node node :templates issue-template)
      (org-roam-with-file (concat org-roam-directory "/" file-name) t
        (current-buffer))
    )))

(defun org-jira--render-issues-from-issue-list (Issues)
  (when (eq 0 (->> Issues (cl-remove-if-not #'org-jira-sdk-isa-issue?) length))
    (setq Issues (org-jira-sdk-create-issues-from-data-list Issues)))
  (setq Issues (cl-remove-if-not #'org-jira-sdk-isa-issue? Issues))
  (org-jira-log (format "About to render %d issues." (length Issues)))
  (mapc 'org-jira--render-issue Issues)
  (org-save-all-org-buffers)
  (org-roam-db-sync)
  (ma/refresh-agenda-files))
#+end_src

**** Keybindings

Redefine org-jira keybindings under C-c j prefix.
#+begin_src emacs-lisp
(map! :prefix ("C-c j" . "jira")
      :desc "refresh" :n "/" #'org-jira-get-issues)
#+end_src

*** Roam

Basic setup.
#+begin_src emacs-lisp
(after! org
  (setq +org-roam-open-buffer-on-find-file nil)) ;; Disable roam buffer when opening a new roam file
#+end_src

Helpers.
#+begin_src emacs-lisp
(defun ma/org-roam-node-category (node)
  (let ((props (org-roam-node-properties node)))
    (alist-get "CATEGORY" props nil nil #'equal)))

(defun ma/org-roam-filter-by-categories (categories)
  (lambda (node)
    (member (ma/org-roam-node-category node) categories)))

(defun ma/org-roam-list-nodes-by-categories (categories)
  (mapcar #'org-roam-node-file
          (seq-filter
           (ma/org-roam-filter-by-categories categories)
           (org-roam-node-list))))
#+end_src

Find file with category.
#+begin_src emacs-lisp
(defun ma/org-roam-find-by-category (category)
  (org-roam-node-find
   nil
   nil
   (lambda (node) (equal (ma/org-roam-node-category node) category))))
#+end_src

Find file with name.
#+begin_src emacs-lisp
(defun ma/org-roam-find-from-this (category)
  (let ((current-name (->> (org-roam-node-at-point)
                           org-roam-node-file
                           file-name-sans-extension)))
    (org-roam-node-find
     nil
     nil
     (lambda (node)
       (and (equal (ma/org-roam-node-category node) category)
            (s-starts-with-p current-name (org-roam-node-file node)))))))
#+end_src

Refresh agenda files after a node with a tracker tag is created.
#+begin_src emacs-lisp
(defun ma/refresh-agenda-hook ()
  (when (org-roam-capture-p)
    (unless org-note-abort
      (when-let* ((id (org-roam-capture--get :id))
                  (node (org-roam-node-from-id id))
                  (category (ma/org-roam-node-category node)))
        (when (member category ma/org-roam-agenda-categories)
          (push (org-roam-node-file node) org-agenda-files))))))

(add-hook 'org-capture-after-finalize-hook #'ma/refresh-agenda-hook)
#+end_src

Immediate insertion.
#+begin_src emacs-lisp
(defun org-roam-node-insert-immediate (arg &rest args)
  (interactive "P")
  (let ((args (cons arg args))
        (org-roam-capture-templates (list (append (car org-roam-capture-templates)
                                                  '(:immediate-finish t)))))
    (apply #'org-roam-node-insert args)))

(map! :map org-mode-map
      :desc "insert" :g "C-c n I" #'org-roam-node-insert-immediate)
#+end_src

**** Capture

Helper function to read contents of a node template from file.
#+begin_src emacs-lisp
(defun ma/read-template (category)
  "Return the contents of FILENAME."
  (with-temp-buffer
    (insert-file-contents (concat org-templates-dir "/" category ".org"))
    (buffer-string)))
#+end_src

Capture with category.
#+begin_src emacs-lisp
(defun ma/org-roam-capture (key category entry target &key jump)
  (let ((template (list key category 'entry
                        entry
                        :target target
                        :unnarrowed t
                        :jump-to-captured jump)))
    (org-roam-capture
     nil
     key
     :filter-fn (lambda (node) (equal (ma/org-roam-node-category node) category))
     :templates (list template))
    ))
#+end_src

Resource captures.
#+begin_src emacs-lisp
(defun ma/org-roam-capture-resource (key category &key jump)
  (ma/org-roam-capture
   key
   category
   "* TODO %?"
   (list 'file+head
         (format "%s.${slug}.org" category)
         (ma/read-template category))
   :jump jump))
#+end_src

Addendum note captures need special treatment.
#+begin_src emacs-lisp
(defun ma/org-roam-capture-addendum (key category file-format &key jump)
  (let* ((head (ma/read-template category))
         (target (list 'file+head file-format head))
         (template (list key category 'plain "%?" :target target :unnarrowed t)))
    (org-roam-capture-
     :keys key
     :node (org-roam-node-create)
     :templates (list template)
     :props (list :default-time (current-time)
                  :immediate-finish nil
                  :jump-to-captured jump))))
#+end_src

Daily captures need special treatment.
#+begin_src emacs-lisp
(cl-defun ma/org-roam-capture-daily-to-heading (key category entry file-format heading &key jump finish plain goto)
  (let* ((org-roam-directory (expand-file-name org-roam-dailies-directory org-roam-directory))
         (head (ma/read-template category))
         (target (list 'file+head+olp file-format head (list heading)))
         (template (list key category
                         (if plain 'plain 'entry)
                         entry
                         :target target
                         :unnarrowed t)))
    (org-roam-capture-
     :goto (when goto '(4))
     :node (org-roam-node-create)
     :templates (list template)
     :props (list :prepend t
                  :override-default-time (current-time)
                  :immediate-finish finish
                  :jump-to-captured jump))
  (when goto (run-hooks 'org-roam-dailies-find-file-hook))))

(cl-defun ma/org-roam-capture-daily (entry heading &key jump finish plain goto)
  (ma/org-roam-capture-daily-to-heading "d" "daily"
                                        entry "%<%Y>/%<%m>/%<%Y.%m.%d>.org" heading
                                        :jump jump
                                        :finish finish
                                        :plain plain
                                        :goto goto))
#+end_src

Inbox capture.
#+begin_src emacs-lisp
(defun ma/capture-inbox ()
  (interactive)
  (let ((inbox-template
         '("x" "inbox" entry
           "* %?"
           :target (file+head "inbox.org" "#+TITLE: Inbox")
           :kill-buffer t
           :unnarrowed t)
         ))
  (org-roam-capture- :node (org-roam-node-create)
                     :templates (list inbox-template))))
#+end_src

**** Dendroam

Basic setup.
#+begin_src emacs-lisp
(use-package! dendroam
  :after org-roam)

(setq org-roam-node-display-template "${hierarchy}:${title}")
#+end_src

Fix dendroam.
#+begin_src emacs-lisp
(setq org-roam-slug-trim-chars '(;; Combining Diacritical Marks https://www.unicode.org/charts/PDF/U0300.pdf
                                   768 ; U+0300 COMBINING GRAVE ACCENT
                                   769 ; U+0301 COMBINING ACUTE ACCENT
                                   770 ; U+0302 COMBINING CIRCUMFLEX ACCENT
                                   771 ; U+0303 COMBINING TILDE
                                   772 ; U+0304 COMBINING MACRON
                                   774 ; U+0306 COMBINING BREVE
                                   775 ; U+0307 COMBINING DOT ABOVE
                                   776 ; U+0308 COMBINING DIAERESIS
                                   777 ; U+0309 COMBINING HOOK ABOVE
                                   778 ; U+030A COMBINING RING ABOVE
                                   780 ; U+030C COMBINING CARON
                                   795 ; U+031B COMBINING HORN
                                   803 ; U+0323 COMBINING DOT BELOW
                                   804 ; U+0324 COMBINING DIAERESIS BELOW
                                   805 ; U+0325 COMBINING RING BELOW
                                   807 ; U+0327 COMBINING CEDILLA
                                   813 ; U+032D COMBINING CIRCUMFLEX ACCENT BELOW
                                   814 ; U+032E COMBINING BREVE BELOW
                                   816 ; U+0330 COMBINING TILDE BELOW
                                   817 ; U+0331 COMBINING MACRON BELOW
                                   ))
#+end_src

**** Keybindings

Set up C-c n keybindings.
#+begin_src emacs-lisp
(map! :prefix ("C-c n" . "notes")
      :desc "refresh" :g "/" #'org-roam-db-sync
      :desc "toggle"  :g "t" #'org-roam-buffer-toggle
      :desc "find"    :g "f" #'org-roam-node-find
      :desc "insert"  :g "i" #'org-roam-node-insert
      :desc "capture" :g "c" #'org-roam-capture)
#+end_src

Set up C-c c capture keybindings.
#+begin_src emacs-lisp
(map! :prefix ("C-c c" . "capture")
      :desc "inbox"   :g "x" #'ma/capture-inbox
      :desc "article" :g "a" (cmd! (ma/org-roam-capture-resource "a" "article" :jump t))
      :desc "goal"    :g "g" (cmd! (ma/org-roam-capture-resource "g" "goal"    :jump t))
      :desc "book"    :g "b" (cmd! (ma/org-roam-capture-resource "b" "book"    :jump t))
      :desc "course"  :g "c" (cmd! (ma/org-roam-capture-resource "c" "course"  :jump t))
      :desc "video"   :g "v" (cmd! (ma/org-roam-capture-resource "v" "video"   :jump t))
      :desc "quote"   :g "q" (cmd! (ma/org-roam-capture-resource "q" "quote"))
      :desc "project" :g "p" (cmd! (ma/org-roam-capture-resource "p" "project" :jump t))
      :desc "zettel"  :g "z" (cmd! (ma/org-roam-capture-resource "z" "zettel"  :jump t)))

(map! :map org-mode-map
      :prefix ("C-c c" . "capture")
      :desc "note"    :g "n" (cmd! (ma/org-roam-capture-addendum "n" "note" "${current-file}.note.%<%Y.%m.%d>.org" :jump t))
      :desc "meeting" :g "m" (cmd! (ma/org-roam-capture-addendum "m" "meeting" "${current-file}.meeting.%<%Y.%m.%d>.org" :jump t))
      :desc "scratch" :g "s" (cmd! (ma/org-roam-capture-addendum "s" "scratch" "scratch.%<%Y.%m.%d.%M%S%3N>.org" :jump t)))

(map! :prefix ("C-c c" . "capture")
      :desc "daily"   :g "d" (cmd! (ma/org-roam-capture-daily "%H:%M : %?" "Journal")))
#+end_src

Set up C-c f find node keybindings.
#+begin_src emacs-lisp
(map! :prefix "C-c f"
      :desc "daily"   :m "d" (cmd! (ma/org-roam-find-by-category "daily"))
      :desc "today"   :m "t" (cmd! (ma/org-roam-capture-daily "" "Journal" :jump t :plain t :goto t))
      :desc "article" :m "a" (cmd! (ma/org-roam-find-by-category "article"))
      :desc "book"    :m "b" (cmd! (ma/org-roam-find-by-category "book"))
      :desc "book"    :m "v" (cmd! (ma/org-roam-find-by-category "video"))
      :desc "goal"    :m "g" (cmd! (ma/org-roam-find-by-category "goal"))
      :desc "quote"   :m "q" (cmd! (ma/org-roam-find-by-category "quote"))
      :desc "course"  :m "c" (cmd! (ma/org-roam-find-by-category "course"))
      :desc "zettel"  :m "z" (cmd! (ma/org-roam-find-by-category "zettel"))
      :desc "scratch" :m "s" (cmd! (ma/org-roam-find-by-category "scratch"))
      :desc "issues"  :m "i" (cmd! (ma/org-roam-find-by-category "issue"))
      :desc "notes"   :m "n" (cmd! (ma/org-roam-find-from-this "note"))
      :desc "meeting" :m "m" (cmd! (ma/org-roam-find-from-this "meeting"))
      :desc "project" :m "p" (cmd! (ma/org-roam-find-by-category "project")))
#+end_src

*** Agenda

Set up org-agenda.
#+begin_src emacs-lisp
(defvar ma/org-roam-agenda-categories
  '("book" "course" "project" "note" "daily" "scratch" "video"))

(defun ma/refresh-agenda-files ()
  (interactive)
  (setq org-agenda-files
        (append
         (list org-habits-file org-events-file org-list-file)
         (ma/org-roam-list-nodes-by-categories ma/org-roam-agenda-categories))))

(after! org
  (ma/refresh-agenda-files)
  (setq org-agenda-start-day nil ; Today
        org-agenda-span 'day     ; Only one day in overview
        org-agenda-dim-blocked-tasks 'dimmed
        org-agenda-start-with-log-mode t
        org-agenda-time-grid `((daily today)
                               ,(mapcar (lambda (time) (* 100 time)) (number-sequence 0 24))
                               ""
                               "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")))
#+end_src

Because agenda API is so poor, i need to switch to task org file every time I want
to do anything complicated. This macro helps me automate the process.
#+begin_src emacs-lisp
(defmacro agenda-cmd! (&rest body)
  (declare (doc-string 1) (pure t) (side-effect-free t))
  `(lambda (&rest _)
     (interactive)
     (let* ((marker (or (org-get-at-bol 'org-marker) (org-agenda-error)))
            (pos (marker-position marker))
            (buffer (marker-buffer marker)))
       (org-with-remote-undo buffer
         (with-current-buffer buffer
           (goto-char pos)
           ,@body)))
     (org-agenda-redo)
     (org-save-all-org-buffers)))
#+end_src

**** Groups

Set up org-super-agenda.
#+begin_src emacs-lisp
(defun ma/get-task-prefix (level)
  "Returns task prefix for sue in hierarchical agenda."
  (let ((level (- (org-outline-level) (+ 1 level))))
    (if (> level 0)
        (format "%s-"
                (make-string (- (* 2 level) 1)
                             ?\s))
      "")))

(defun ma/skip-if-blocked ()
  (let ((next-headline (save-excursion
                         (or (outline-next-heading) (point-max)))))
    (if (org-entry-blocked-p) next-headline)))

(defun ma/agenda-project-name (item)
  (-when-let* ((marker (org-super-agenda--get-marker item))
               (file-name (->> marker marker-buffer buffer-name)))
    (concat "Project: " file-name)))

(defun ma/get-keyword-key-value (kwd)
  (let ((data (cadr kwd)))
    (list (plist-get data :key)
          (plist-get data :value))))

(defun ma/org-current-buffer-get-title ()
  (nth 1
       (assoc
        "TITLE"
        (org-element-map
            (org-element-parse-buffer 'greater-element)
            '(keyword)
          #'ma/get-keyword-key-value))))

(defun ma/org-file-get-title (file)
  (with-current-buffer (find-file-noselect file)
    (ma/org-current-buffer-get-title)))

(defun ma/agenda-title (item)
  (when-let ((marker (org-super-agenda--get-marker item)))
    (->> marker marker-buffer buffer-name ma/org-file-get-title)))

(defun ma/agenda-issue-name (item)
  (when-let ((title (ma/agenda-title item)))
    (concat "Issue: " title)))

(defun ma/agenda-goal-name (item)
  (when-let ((title (ma/agenda-title item)))
    (concat "Goal: " title)))

(defun ma/get-habit-time-prefix ()
  (let ((time (org-entry-get (point) "TIME")))
    (cond ((equal time "morning") "M")
          ((equal time "evening") "E")
          (t " "))))

(use-package! org-super-agenda
  :after org-agenda
  :init
  (setq org-agenda-custom-commands
        '( ;; A list of commands
          ("a" "Agenda view"
           ( ;; A list of sections
            (agenda "" ((org-agenda-overriding-header "")
                        (org-agenda-prefix-format "   %-20c :   %05e    :   %5t  %(ma/get-habit-time-prefix) ")
                        (org-agenda-time-grid nil)
                        (org-super-agenda-groups
                         '((:discard (:todo "DONE"))
                           (:name "Closed"
                            :log closed
                            :order 0)
                           (:name "Habits"
                            :habit t
                            :order 2)
                           (:name "Today"
                            :and (:todo "NEXT"
                                  :date today)
                            :order 1)
                            (:discard (:anything t))
                           ))))
            (alltodo "" ((org-agenda-overriding-header "")
                         (org-agenda-prefix-format "   %-20c :   %05e    :     %5t  ")
                         (org-agenda-time-grid nil)
                         (org-agenda-skip-function 'ma/skip-if-blocked)
                         (org-super-agenda-groups
                          '((:discard (:scheduled future))
                            (:discard (:habit t))
                            (:name "Executing"
                             :todo "EXEC"
                             :order 1)
                            (:name "Tasks"
                             :and (:todo "NEXT"
                                   :category "task")
                             :order 2)
                            (:name "Learning"
                             :and (:todo "NEXT"
                                   :category ("book" "course" "article" "video"))
                             :order 3)
                            (:name "Issues"
                             :and (:todo "NEXT"
                                   :category "issue")
                             :order 4)
                            (:name "On hold"
                             :todo "HOLD"
                             :order 5)
                            (:name "Waiting"
                             :todo "WAIT"
                             :order 6)
                            (:discard (:anything t))
                           ))))
            ))
          ("t" "Tasks view"
           ( ;; A list of sections
            (alltodo "" ((org-agenda-overriding-header "")
                         (org-agenda-prefix-format "   %-20c :   %05e    :     %5t  %(ma/get-task-prefix 1) ")
                         (org-agenda-time-grid nil)
                         (org-super-agenda-groups
                          '((:discard (:file-path "issue\\."))
                            (:discard (:file-path "project\\."))
                            (:discard (:todo "MAYBE"))
                            (:name "Tasks"
                             :category "task"
                             :order 1)
                            (:discard (:anything t))
                           ))))))
          ("p" "Projects view"
           ( ;; A list of sections
            (alltodo "" ((org-agenda-overriding-header "")
                         (org-agenda-prefix-format "   %-20c :   %05e    :     %5t  %(ma/get-task-prefix 1) ")
                         (org-agenda-time-grid nil)
                         (org-super-agenda-groups
                          '((:discard (:not (:file-path "project\\.")))
                            (:name "Project tasks"
                             :auto-map ma/agenda-project-name
                             :order 1)
                            (:discard (:anything t))
                           ))))))
          ("g" "Goals view"
           ( ;; A list of sections
            (alltodo "" ((org-agenda-overriding-header "")
                         (org-agenda-prefix-format "   %-20c :   %05e    :     %5t  %(ma/get-task-prefix 1) ")
                         (org-agenda-time-grid nil)
                         (org-super-agenda-groups
                          '((:discard (:not (:file-path "goal\\.")))
                            (:name "Goals and steps"
                             :auto-map ma/agenda-goal-name
                             :order 1)
                            (:discard (:anything t))
                           ))))))
          ("i" "Issues view"
           ( ;; A list of sections
            (alltodo "" ((org-agenda-overriding-header "")
                         (org-agenda-prefix-format "   %-20c :   %05e    :     %5t  %(ma/get-task-prefix 1) ")
                         (org-agenda-time-grid nil)
                         (org-super-agenda-groups
                          '((:discard (:not (:file-path "issue\\.")))
                            (:name "Issue tasks"
                             :auto-map ma/agenda-issue-name
                             :order 1)
                            (:discard (:anything t))
                           ))))))
          ("u" "Incubators"
           ( ;; A list of sections
            (alltodo "" ((org-agenda-overriding-header "")
                         (org-agenda-prefix-format "   %-20c :     %5t  ")
                         (org-agenda-time-grid nil)
                         (org-super-agenda-groups
                          '((:discard (:not (:todo "MAYBE")))
                            (:auto-tags t
                             :order 1)
                            (:discard (:anything t))
                           ))))))
          ("l" "Learning view"
           ( ;; A list of sections
            (alltodo "" ((org-agenda-overriding-header "Daily Goals")
                         (org-agenda-prefix-format "   %-20c :      %5t ")
                         (org-agenda-skip-function 'ma/skip-if-blocked)
                         (org-agenda-time-grid nil)
                         (org-super-agenda-groups
                          '((:discard (:not (:category ("article" "book" "course"))))
                            (:name "Learning"
                             :todo ("NEXT" "EXEC" "TDAY")
                             :order 1)
                            (:discard (:anything t))
                            ))))
            (alltodo "" ((org-agenda-overriding-header "Weekly Goals")
                         (org-agenda-prefix-format "   %-20c :    %5t  %(ma/get-task-prefix 0) ")
                         (org-agenda-time-grid nil)
                         (org-super-agenda-groups
                          '((:discard (:not (:category ("article" "book" "course"))))
                            (:discard (:todo ("DONE" "TODO")))
                            (:name "Learning"
                             :auto-map ma/agenda-title
                             :order 1)
                            (:discard (:anything t))
                            ))))))
          ("v" "Videos view"
           ( ;; A list of sections
            (alltodo "" ((org-agenda-overriding-header "Weekly Goals")
                         (org-agenda-prefix-format "   %-20c :    %5t  %(ma/get-task-prefix 0) ")
                         (org-agenda-time-grid nil)
                         (org-super-agenda-groups
                          '((:discard (:not (:category ("video"))))
                            (:name "Videos"
                             :auto-map ma/agenda-title
                             :order 1)
                            (:discard (:anything t))
                            ))))))
          ("n" "Notes view"
           ( ;; A list of sections
            (alltodo "" ((org-agenda-overriding-header "")
                         (org-agenda-prefix-format "   %-20c :     %5t  ")
                         (org-agenda-time-grid nil)
                         (org-super-agenda-groups
                          '((:discard (:tag ("2read" "2watch")))
                            (:name "Notes"
                             :and (:todo "TODO"
                                   :category ("note" "scratch"))
                             :order 2)
                            (:discard (:anything t))
                            ))))))
          ("ww" "Shopping"
           ( ;; A list of sections
            (alltodo "" ((org-agenda-overriding-header "Shopping")
                         (org-agenda-prefix-format "   %-20c :     %5t  ")
                         (org-agenda-time-grid nil)
                         (org-super-agenda-groups
                          '((:discard (:not (:category "list")))
                            (:auto-parent t
                             :order 1)
                            (:discard (:anything t))
                            ))))))
          ("wa" "Articles"
           ( ;; A list of sections
            (alltodo "" ((org-agenda-overriding-header "Articles")
                         (org-agenda-prefix-format "   %-20c :     %5t  ")
                         (org-agenda-time-grid nil)
                         (org-super-agenda-groups
                          '((:discard (:not (:tag "article")))
                            (:auto-tags t
                             :order 1)
                            (:discard (:anything t))
                            ))))))
          ("wb" "Books"
           ( ;; A list of sections
            (alltodo "" ((org-agenda-overriding-header "Books")
                         (org-agenda-prefix-format "   %-20c :     %5t  ")
                         (org-agenda-time-grid nil)
                         (org-super-agenda-groups
                          '((:discard (:not (:tag "book")))
                            (:auto-tags t
                             :order 1)
                            (:discard (:anything t))
                            ))))))
          ("wc" "Courses"
           ( ;; A list of sections
            (alltodo "" ((org-agenda-overriding-header "Courses")
                         (org-agenda-prefix-format "   %-20c :     %5t  ")
                         (org-agenda-time-grid nil)
                         (org-super-agenda-groups
                          '((:discard (:not (:tag "course")))
                            (:auto-tags t
                             :order 1)
                            (:discard (:anything t))
                            ))))))
          ("d" "Daily view"
           ( ;; A list of sections
            (agenda "" ((org-agenda-overriding-header "")
                        (org-agenda-prefix-format "   %5t  ")
                        (org-super-agenda-groups
                         '((:discard (:habit t))
                           (:name "Today"
                            :time-grid t
                            :date today
                            :order 1)
                           (:discard (:anything t))
                           ))))))
          ))
  :config
  (org-super-agenda-mode t))
#+end_src

**** Keybindings

Set up keybindings.
#+begin_src emacs-lisp
(map! :after evil-org-agenda
      :map (org-agenda-mode-map evil-org-agenda-mode-map org-super-agenda-header-map)
      :desc "prev"     :g "k"     #'org-agenda-previous-line
      :desc "next"     :g "j"     #'org-agenda-next-line)

(map! :after org-agenda
      :map org-agenda-mode-map
      ;; Entry manipulation
      :prefix "C-c"
      :desc "complete" :g "d" (agenda-cmd! (ma/task-done))
      :desc "hold"     :g "h" (agenda-cmd! (ma/task-hold))
      :desc "wait"     :g "w" (agenda-cmd! (ma/task-wait))
      :desc "execute"  :g "x" (agenda-cmd! (ma/task-toggle))
      :desc "schedule" :g "s" (agenda-cmd! (org-schedule nil))
      :desc "deadline" :g "l" (agenda-cmd! (org-deadline nil))
      :desc "tag"      :g "t" (agenda-cmd! (org-ctrl-c-ctrl-c))
      :desc "effort"   :g "e" (agenda-cmd! (org-set-effort))
      ;; Filtering
      :prefix ("C-c a f" . "filter")
      :desc "by tag"    :m "t" #'org-agenda-filter-by-tag
      :desc "by effort" :m "e" #'org-agenda-filter-by-effort)

(map! :prefix ("C-c a" . "agenda")
      :desc "refresh"    :g "/"   #'ma/refresh-agenda-files
      :desc "agenda"     :g "a"   (cmd! (org-agenda nil "a"))
      :desc "tasks"      :g "t"   (cmd! (org-agenda nil "t"))
      :desc "incubators" :g "u"   (cmd! (org-agenda nil "u"))
      :desc "goals"      :g "g"   (cmd! (org-agenda nil "g"))
      :desc "projects"   :g "p"   (cmd! (org-agenda nil "p"))
      :desc "issues"     :g "i"   (cmd! (org-agenda nil "i"))
      :desc "videos"     :g "v"   (cmd! (org-agenda nil "v"))
      :desc "learning"   :g "l"   (cmd! (org-agenda nil "l"))
      :desc "notes"      :g "n"   (cmd! (org-agenda nil "n"))
      :desc "daily"      :g "d"   (cmd! (org-agenda nil "d"))
      :prefix ("C-c a w" . "wishes")
      :desc "shopping"   :g "w"   (cmd! (org-agenda nil "ww"))
      :desc "articles"   :g "a"   (cmd! (org-agenda nil "wa"))
      :desc "books"      :g "b"   (cmd! (org-agenda nil "wb"))
      :desc "courses"    :g "c"   (cmd! (org-agenda nil "wc"))
      )
#+end_src

*** Refiling

Set up general refiling parameters.
#+begin_src emacs-lisp
(setq org-refile-use-outline-path 'file
      org-outline-path-complete-in-steps nil
      org-refile-allow-creating-parent-nodes 'confirm)
#+end_src

General refiling function provides a better interface than out-of-the-box org-refile.
#+begin_src emacs-lisp
(defun ma/refile (target heading &optional arg default-buffer msg)
  "Refile entries with top-level PARENT under the (exact) HEADING in FILE."
  (let* ((position
          (if heading
              (with-current-buffer (find-file-noselect target)
                (or (org-find-exact-headline-in-buffer heading)
                    (org-end-of-subtree t t)))))
         (rfloc `(,heading ,target nil ,position))
         (org-after-refile-insert-hook #'save-buffer))
    (org-refile arg default-buffer rfloc msg)))
#+end_src

Interactive refile to file.
#+begin_src emacs-lisp
(defun ma/refile-to-file (file state &optional follow)
  (interactive)
  (org-todo state)
  (org-entry-put (point) "ORDERED" "t")
  (ma/refile file nil)
  (when follow
    (org-refile-goto-last-stored)))
#+end_src

Refile a task to today's daily note.
#+begin_src emacs-lisp
(defun ma/refile-task (&optional state follow)
  (interactive)
  (let ((org-refile-keep nil) ;; Set this to t to keep the original
        (org-after-refile-insert-hook #'save-buffer)
        today-file
        pos)
    (save-window-excursion
      (ma/org-roam-capture-daily "%?" "Tasks" :goto t)
      (setq today-file (buffer-file-name))
      (setq pos (point)))
    ;; Only refile if the target file is different than the current file
    (unless (equal (file-truename today-file)
                   (file-truename (buffer-file-name)))
      (org-todo state)
      (org-entry-put (point) "ORDERED" "t")
      (org-refile nil nil (list "Tasks" today-file nil pos))
      (when follow
        (org-refile-goto-last-stored)))))
#+end_src

Refile to habits file. This functions adds formating to make an item into a habit.
#+begin_src emacs-lisp
(defun ma/refile-to-habits ()
  "Move the current subtree from processing to a habits."
  (interactive)
  (org-todo "TODO")
  (org-insert-property-drawer)
  (org-entry-put (point) "STYLE" "habit")
  (org-entry-put (point) "LAST_REPEAT" nil)
  (let* ((date (org-read-date))
         (min (read-number "Do the habit no often than this many days: " 1))
         (max (read-number "Do the habit at least once in this many days: " 1))
         (repeat-str
          (if (>= min max)
              (format ".+%dd" min)
              (format ".+%dd/%dd"))))
    (org-schedule nil (message "<%s %s>" date repeat-str))
    (ma/refile org-habits-file nil)))
#+end_src

**** Keybindings

Set up C-c keybindings.
#+begin_src emacs-lisp
(map! :map (org-mode-map org-agenda-mode-map)
      :prefix ("C-c r" . "refile")
      :desc "refile"     :n "/" #'org-refile
      :desc "task"       :n "t" (cmd! (ma/refile-task "NEXT"))
      :desc "event"      :n "e" (cmd! (ma/refile-to-file org-events-file "TODO"))
      :desc "habits"     :n "h" #'ma/refile-to-habits
      :desc "incubate"   :n "u" (cmd! (ma/refile-task "MAYBE")))
#+end_src

*** States

Defininig my (extremenly simple) state machine.
#+begin_src emacs-lisp
(defun ma/task-start (state)
  (when (member (org-get-todo-state) '("NEXT" "HOLD"))
    (org-todo state)
    (org-clock-in)))

(defun ma/task-stop (state)
  (when (equal (org-get-todo-state) "EXEC")
    (org-todo state)
    (org-clock-out nil t)))

(defun ma/task-done ()
  (org-todo "DONE"))

(defun ma/task-hold ()
  (org-todo "HOLD")
  (org-clock-out nil t))

(defun ma/task-wait ()
  (org-todo "WAIT"))

(defun ma/task-toggle ()
  (interactive)
  (let ((todo-state (org-get-todo-state)))
    (cond ((equal todo-state "NEXT") (ma/task-start "EXEC"))
          ((equal todo-state "HOLD") (ma/task-start "EXEC"))
          ((equal todo-state "EXEC") (ma/task-stop "NEXT")))))
#+end_src

Define helper functions.
#+begin_src emacs-lisp
(defun ma/is-top-level ()
  (equal (org-outline-level) 2)) ;; 2 because tasks live under Tasks heading

(defun ma/has-tag (tag)
  (member tag (org-get-tags)))
#+end_src

I want my hooks to run in specific files only. This macro will automate file name checking.
#+begin_src emacs-lisp
(defvar ma/todo-completion-categories nil)

(defmacro todo-completion! (fn)
  "Run command only in buffer specified by `ma/todo-completion-category'."
  (declare (doc-string 1) (pure t) (side-effect-free t))
  `(lambda (&rest rest)
    (when (member (org-get-category) ma/todo-completion-categories)
      (interactive)
      (apply ,fn rest))))
#+end_src

I need a way to automatically make next item become "NEXT" when the current one changes to "DONE".
#+begin_src emacs-lisp
(defun ma/complete-and-continue ()
  "Switch current heading to DONE and next to NEXT."
  (interactive)
  (unless (ma/is-top-level)
    (when (save-excursion (outline-get-next-sibling))
      (org-forward-heading-same-level 1)
      (org-todo "NEXT"))))
#+end_src

I need to auto-done parents when all childrern are "DONE" or checked.
#+begin_src emacs-lisp
(defun ma/summary-todo (n-done n-not-done)
  "Switch entry to DONE when all subentries are done."
  (when (= n-not-done 0) (org-todo "DONE")))
#+end_src

I need to set the next sibling to "NEXT" when the current one is "DONE".
#+begin_src emacs-lisp
(defun ma/complete (change)
  (let ((from-state (plist-get change :from))
        (to-state (plist-get change :to)))
    (when (and (member from-state '("NEXT" "EXEC" "HOLD" "WAIT" "TDAY")) (equal to-state "DONE"))
      (unless (ma/is-top-level)
        (ma/complete-and-continue)))))
#+end_src

Use what I defined in the todo hooks.
#+begin_src emacs-lisp
(after! org
  (setq ma/todo-completion-categories '("task" "book" "course" "article")))

(after! org
  (add-hook 'org-after-todo-statistics-hook (todo-completion! 'ma/summary-todo))
  (add-hook 'org-trigger-hook (todo-completion! 'ma/complete)))
#+end_src

*** Clocking

Clocking setup
#+begin_src emacs-lisp
(after! org
  (setq org-clock-out-when-done t))
#+end_src

Set up a hook to save clocked time to dailies
#+begin_src emacs-lisp
(defun ma/agenda-get-heading (&optional NO-TAGS NO-TODO NO-PRIORITY NO-COMMENT)
  (let* ((marker (or (org-get-at-bol 'org-marker) (org-agenda-error)))
         (pos (marker-position marker))
         (buffer (marker-buffer marker)))
    (with-current-buffer buffer
      (goto-char pos)
      (org-get-heading NO-TAGS NO-TODO NO-PRIORITY NO-COMMENT))))

(defun ma/clock-out-handler ()
  (let* ((start-time (format-time-string "%H:%M" org-clock-start-time))
         (end-time (format-time-string "%H:%M" org-clock-out-time))
         (heading (if (equal major-mode 'org-agenda-mode)
                      (ma/agenda-get-heading t t t t)
                    (org-get-heading t t t t)))
         (entry (format "** %s - %s : %s" start-time end-time heading)))
    (ma/org-roam-capture-daily entry "Journal" :finish t :plain t)
    ))

(after! org-roam
  (add-hook 'org-clock-out-hook 'ma/clock-out-handler))
#+end_src

* DEVELOPMENT
** Treemacs

#+begin_src emacs-lisp
(after! treemacs
  (set-face-attribute 'treemacs-root-face nil :height 1.0)
  (setq treemacs-no-png-images t
        doom-themes-treemacs-variable-pitch-face nil
        doom-themes-treemacs-line-spacing 0.4))
#+end_src
** Rust

Set up rust-analyzer.
#+begin_src emacs-lisp
(use-package! lsp-rust
  :init
  (setq! lsp-rust-analyzer-cargo-watch-enable t
         lsp-rust-analyzer-cargo-watch-command "clippy"
         lsp-rust-analyzer-proc-macro-enable t
         lsp-rust-analyzer-cargo-load-out-dirs-from-check t
         lsp-rust-analyzer-server-display-inlay-hints t
         lsp-rust-analyzer-display-chaining-hints t
         lsp-rust-analyzer-display-parameter-hints t))
#+end_src
