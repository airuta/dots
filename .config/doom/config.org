#+TITLE: Airuta's Literate Config
#+AUTHOR: Mori Airuta
#+STARTUP: overview num

* INITIAL SETUP

User information.
#+begin_src emacs-lisp
(setq user-full-name "Mori Airuta"
      user-mail-address "mori.airuta@gmail.com")
#+end_src

Drive folder.
#+begin_src emacs-lisp
(setq drive-folder "~/Dropbox")
#+end_src

* UI & BEHAVIOR

Select a theme.
#+begin_src emacs-lisp
(setq doom-theme 'doom-tomorrow-day) ;; Other good themes: doom-one, doom-vibrant.
#+end_src

Define colors for todo keywords.
#+begin_src emacs-lisp
(setq todo-colors
      '(("TODO"      . (:foreground "#E6B168" :weight normal))
        ("NEXT"      . (:foreground "#ED6165" :weight normal))
        ("HOLD"      . (:foreground "#439EEA" :wegiht normal))
        ("EXEC"      . (:foreground "#ED6165" :weight bold))
        ("DONE"      . (:foreground "#88B453" :weight normal))
        ("CANCELED"  . (:foreground "#998CD9" :weight normal))))
#+end_src

Font and line spacing.
#+begin_src emacs-lisp
(setq doom-font (font-spec :family "Lekton Nerd Font Mono" :size 14 :weight 'normal))
(setq-default line-spacing 0.4)
#+end_src

Set up line numbers.
#+begin_src emacs-lisp
(setq display-line-numbers-type t)
(setq display-line-numbers-type 'relative)
#+end_src

Disable exit prompt.
#+begin_src emacs-lisp
(setq confirm-kill-emacs nil)
#+end_src

Setup modeline to make it look more terminal-like.
#+begin_src emacs-lisp
(setq doom-modeline-height 20
      doom-modeline-major-mode-color-icon nil
      doom-modeline-buffer-modification-icon nil
      doom-modeline-buffer-state-icon nil)
#+end_src

Define convenient window movement.
#+begin_src emacs-lisp
(map! :after evil
      ;; Navigation
      :n "H"   #'evil-window-left
      :n "J"   #'evil-window-down
      :n "K"   #'evil-window-up
      :n "L"   #'evil-window-right)
#+end_src

Disable mouse highlight. Why is it even enabled by default?
#+begin_src emacs-lisp
(setq mouse-highlight nil)
#+end_src

* MODULE SETUP

Set up which key delays.
#+begin_src emacs-lisp
(after! which-key
  (setq! which-key-idle-delay 0
         which-key-idle-secondary-delay 0))
#+end_src

Remove icons from treemacs.
#+begin_src emacs-lisp
(after! treemacs
  (setq treemacs-no-png-images t))
#+end_src

Set up projectile default path.
#+begin_src emacs-lisp
(after! projectile
  (setq projectile-project-search-path (concat drive-folder "/forge")))
#+end_src

* ORG MODE

Make property inheritance work.
#+begin_src emacs-lisp
(after! org
  (load! "lisp/props"))
#+end_src

Replace boring org bullet with trigrams.
#+begin_src emacs-lisp
(use-package! org-superstar
  :config
  (add-hook 'org-mode-hook (lambda () (org-superstar-mode 1)))
  (setq org-superstar-headline-bullets-list '("☱" "☲" "☳" "☴" "☵" "☶" "☷")))
#+end_src

Prettify org mode a bit.
#+begin_src emacs-lisp
(after! org
  (setq org-ellipsis " ▾"))
#+end_src

** GTD

Basic definitions.
#+begin_src emacs-lisp
(setq org-directory (concat drive-folder "/org")
      org-default-notes-file (concat org-directory "/inbox.org")
      org-roam-directory (concat org-directory "/cortex")
      ;; Files
      org-inbox-file      org-default-notes-file
      org-notes-file      (concat org-directory "/notes.org")
      org-events-file     (concat org-directory "/events.org")
      org-tasks-file      (concat org-directory "/tasks.org")
      org-habits-file     (concat org-directory "/habits.org")
      org-list-file       (concat org-directory "/list.org")
      ;; Dirs
      org-cortex-dir      org-roam-directory
      org-templates-dir   (concat org-cortex-dir "/templates/")
      org-incubator-dir   (concat org-directory "/incubator/")
      org-ledger-dir      (concat org-directory "/ledger/"))
#+end_src

Set up go-to keybindings.
#+begin_src emacs-lisp
(map! :leader
      :prefix ("r f" . "files")
      :desc "inbox"    :n "x" (cmd! (find-file org-inbox-file))
      :desc "tasks"    :n "t" (cmd! (find-file org-tasks-file))
      :desc "events"   :n "e" (cmd! (find-file org-events-file))
      :desc "habits"   :n "h" (cmd! (find-file org-habits-file))
      :desc "list"     :n "l" (cmd! (find-file org-list-file))
      :desc "projects" :n "P" (cmd! (dired org-projects-dir))
      :desc "books"    :n "B" (cmd! (dired org-books-dir))
      :desc "courses"  :n "C" (cmd! (dired org-courses-dir))
      :desc "tech"     :n "T" (cmd! (dired org-tech-dir))
      :desc "ledger"   :n "L" (cmd! (dired org-ledger-dir))
      :desc "journal"  :n "J" (cmd! (dired org-journal-dir)))
#+end_src

Define some keys for convenience.
#+begin_src emacs-lisp
(map! :desc "agenda"     :m "C-c a" #'org-agenda
      :desc "prev-hl"    :m "C-k"   #'org-previous-visible-heading
      :desc "next-hl"    :m "C-j"   #'org-next-visible-heading)

(map! :map org-mode-map
      :desc "store link" :n "C-c l" #'org-store-link
      :desc "execute"    :n "C-c x" #'ma/toggle-exec
      :desc "complete"   :n "C-c d" (cmd! (ma/clock-out) (org-todo "DONE"))
      :desc "hold"       :n "C-c h" (cmd! (ma/clock-out) (org-todo "HOLD"))
      :desc "schedule"   :n "C-c s" #'org-schedule
      :desc "deadline"   :n "C-c l" #'org-deadline
      :desc "tag"        :n "C-c t" #'org-ctrl-c-ctrl-c
      :desc "effort"     :n "C-c e" #'org-set-effort)

(map! :map org-mode-map
      :leader
      :prefix ("r" . "org")
      :desc "effort"     :n "e" #'org-set-effort
      :desc "tag"        :n "t" #'org-ctrl-c-ctrl-c
      :desc "schedule"   :n "s" #'org-schedule
      :desc "deadline"   :n "l" #'org-deadline)
#+end_src

*** States

Org mode todo items keywords.
#+begin_src emacs-lisp
(after! org
  (setq org-todo-keywords '((sequence "TODO(t)" "NEXT(n)" "HOLD(h)" "EXEC(e)" "|" "DONE(d)" "CANCELED(c)"))
        org-todo-keyword-faces todo-colors
        org-enforce-todo-dependencies t))
#+end_src

Toggle NEXT and EXEC states.
#+begin_src emacs-lisp
(defun ma/toggle-exec ()
  (interactive)
  (let ((todo-state (org-get-todo-state)))
    (cond ((equal todo-state "NEXT") (org-todo "EXEC") (org-clock-in))
          ((equal todo-state "HOLD") (org-todo "EXEC") (org-clock-in))
          ((equal todo-state "EXEC") (org-todo "NEXT") (org-clock-out)))))
#+end_src

Define helper functions.
#+begin_src emacs-lisp
(defun ma/is-top-level ()
  (equal (org-outline-level) 1))

(defun ma/has-tag (tag)
  (member tag (org-get-tags)))
#+end_src

I want my hooks to run in specific files only. This macro will automate file name checking.
#+begin_src emacs-lisp
(defvar ma/todo-completion-files nil)

(defmacro todo-completion! (fn)
  "Run command only in buffer specified by `ma/todo-completion-files'."
  (declare (doc-string 1) (pure t) (side-effect-free t))
  `(lambda (&rest rest)
    (when (member (buffer-name) ma/todo-completion-files)
      (interactive) (apply ,fn rest))))
#+end_src

I need a way to automatically make next item become "NEXT" when the current one changes to "DONE".
#+begin_src emacs-lisp
(defun ma/complete-and-continue ()
  "Switch current heading to DONE and next to NEXT."
  (interactive)
  (unless (ma/is-top-level)
    (when (save-excursion (outline-get-next-sibling))
      (org-forward-heading-same-level 1)
      (org-todo "NEXT"))))
#+end_src

I need to auto-done parents when all childrern are "DONE" or checked.
#+begin_src emacs-lisp
(defun ma/summary-todo (n-done n-not-done)
  "Switch entry to DONE when all subentries are done."
  (when (= n-not-done 0) (org-todo "DONE")))
#+end_src

I need to set the next sibling to "NEXT" when the current one is "DONE".
#+begin_src emacs-lisp
(defun ma/complete (change)
  (let ((from-state (plist-get change :from))
        (to-state (plist-get change :to)))
    (when (and (member from-state '("NEXT" "EXEC")) (equal to-state "DONE"))
      (unless (ma/is-top-level)
        (ma/complete-and-continue)))))
#+end_src

Use what I defined in the todo hooks.
#+begin_src emacs-lisp
(setq ma/todo-completion-files '("tasks.org"))

(after! org
  (add-hook 'org-after-todo-statistics-hook (todo-completion! 'ma/summary-todo))
  (add-hook 'org-trigger-hook (todo-completion! 'ma/complete)))
#+end_src

I need property inheritance for ordered tasks to work.
#+begin_src emacs-lisp
(setq org-use-property-inheritance '("ORDERED" "SCHEDULED"))
#+end_src

*** Habits

Enable org-habit.
#+begin_src emacs-lisp
(setq org-log-into-drawer t
      org-habit-show-habits-only-for-today nil
      org-habit-show-all-today t
      org-habit-graph-column 40
      org-habit-following-days 3
      org-habit-preceding-days 7)
(after! org
  (add-to-list 'org-modules 'org-habit))
#+end_src

*** Agenda

Set up org-agenda.
#+begin_src emacs-lisp
(defvar ma/roam-agenda-tags
  '("book" "course" "project" "note"))

(defun ma/org-roam-filter-by-tag (tags)
  (lambda (node)
    (funcall #'or
           (mapcar (lambda (tag) (member tag (org-roam-node-tags node)))
                   tags))))

(defun ma/org-roam-list-notes-by-tag (tags)
  (mapcar #'org-roam-node-file
          (seq-filter
           (ma/org-roam-filter-by-tag tags)
           (org-roam-node-list))))

(after! org
  (setq org-agenda-files
        (append
         (list org-tasks-file org-habits-file org-events-file org-list-file)
         (ma/org-roam-list-notes-by-tag ma/roam-agenda-tags)))
  (setq org-agenda-start-day nil ; Today
        org-agenda-span 'day     ; Only one day in overview
        org-agenda-dim-blocked-tasks 'dimmed
        org-agenda-start-with-log-mode t
        org-agenda-time-grid `((daily today)
                               ,(mapcar (lambda (time) (* 100 time)) (number-sequence 0 24))
                               ""
                               "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")))
#+end_src

Set up org-super-agenda.
#+begin_src emacs-lisp
(defun ma/get-task-prefix ()
  "Returns task prefix for sue in hierarchical agenda."
  (let ((level (- (org-outline-level) 1)))
    (if (> level 0)
        (format "%s-"
                (make-string (- (* 2 level) 1)
                             ?\s))
      "")))

(defun ma/skip-if-blocked ()
  (let ((next-headline (save-excursion
                         (or (outline-next-heading) (point-max)))))
    (if (org-entry-blocked-p) next-headline)))

(use-package! org-super-agenda
  :after org-agenda
  :init
  (setq org-agenda-custom-commands
        '( ;; A list of commands
          ("a" "Agenda view"
           ( ;; A list of sections
            (agenda "" ((org-agenda-overriding-header "")
                        (org-agenda-prefix-format "   %-20c ::   %5t  ")
                        (org-agenda-time-grid nil)
                        (org-super-agenda-groups
                         '((:name "Habits"
                            :habit t
                            :order 2)
                           (:name "Today"
                            :date today
                            :order 1)
                            (:discard (:anything t))
                           ))))
            (alltodo "" ((org-agenda-overriding-header "")
                         (org-agenda-prefix-format "   %-20c ::   %5t  ")
                         (org-agenda-time-grid nil)
                         (org-agenda-skip-function 'ma/skip-if-blocked)
                         (org-super-agenda-groups
                          '((:discard (:scheduled future))
                            (:name "Executing"
                             :todo "EXEC"
                             :order 1)
                            (:name "Shopping"
                             :tag "shopping"
                             :order 3)
                            (:name "Next"
                             :and (:todo ("NEXT" "HOLD")
                                   :not (:habit t))
                             :order 2)
                            (:discard (:anything t))
                           ))))
            ))
          ("t" "Tasks view"
           ( ;; A list of sections
            (alltodo "" ((org-agenda-overriding-header "")
                         (org-agenda-prefix-format "   %-20c ::   %5t  %(ma/get-task-prefix) ")
                         (org-agenda-time-grid nil)
                         (org-super-agenda-groups
                          '((:name "Tasks"
                             :tag "task"
                             :order 1)
                            (:discard (:anything t))
                           ))))))
          ("l" "Learning view"
           ( ;; A list of sections
            (alltodo "" ((org-agenda-overriding-header "")
                         (org-agenda-prefix-format "   %-20c ::   %5t  %(ma/get-task-prefix) ")
                         (org-agenda-time-grid nil)
                         (org-super-agenda-groups
                          '((:name "Learning"
                             :and (:todo "NEXT" :tag ("book" "course"))
                             :order 2)
                            (:discard (:anything t))
                            ))))))
          ("n" "Notes view"
           ( ;; A list of sections
            (alltodo "" ((org-agenda-overriding-header "")
                         (org-agenda-prefix-format "   %-20c ::   %5t  ")
                         (org-agenda-time-grid nil)
                         (org-super-agenda-groups
                          '((:name "Notes"
                             :and (:todo "TODO" :tag "note")
                             :order 2)
                            (:discard (:anything t))
                            ))))))
          ("g" "Time grid view"
           ( ;; A list of sections
            (agenda "" ((org-agenda-overriding-header "")
                        (org-agenda-prefix-format "   %05t  ")
                        (org-super-agenda-groups
                         '((:name "Today"
                            :time-grid t
                            :date today
                            :order 1)
                           (:discard (:anything t))
                           ))))))
          ))
  :config
  (org-super-agenda-mode t))
#+end_src

Getting todo state of the current item in agenda is not as trivial as I expected.
#+begin_src emacs-lisp
(defun ma/agenda-toggle-exec ()
  (interactive)
   (let* ((marker (or (org-get-at-bol 'org-marker) (org-agenda-error)))
          (pos (marker-position marker))
          (buffer (marker-buffer marker)))
     (message "buffer: %s" buffer)
     (org-with-remote-undo buffer
       (with-current-buffer buffer
         (goto-char pos)
         (call-interactively 'ma/toggle-exec)))))
#+end_src

Set up keybindings.
#+begin_src emacs-lisp
(defmacro agenda-cmd! (&rest body)
  (declare (doc-string 1) (pure t) (side-effect-free t))
  `(lambda (&rest _)
     (interactive)
     ,@body
     (org-agenda-redo)
     (org-save-all-org-buffers)))

(map! :after org-agenda
      :map org-agenda-mode-map
      :desc "complete" :m "C-c d" (agenda-cmd! (ma/agenda-clock-out) (org-agenda-todo "DONE"))
      :desc "hold"     :m "C-c h" (agenda-cmd! (ma/agenda-clock-out) (org-agenda-todo "HOLD"))
      :desc "execute"  :m "C-c x" (agenda-cmd! (ma/agenda-toggle-exec))
      :desc "schedule" :m "C-c s" (agenda-cmd! (org-agenda-schedule nil))
      :desc "deadline" :m "C-c l" (agenda-cmd! (org-agenda-deadline nil))
      :desc "tag"      :m "C-c t" (agenda-cmd! (org-agenda-ctrl-c-ctrl-c))
      :desc "effort"   :m "C-c e" (agenda-cmd! (org-agenda-set-effort)))

(map! :leader
      :prefix ("r a" . "agenda")
      :desc "agenda"     :m "a"   (cmd! (org-agenda nil "a"))
      :desc "tasks"      :m "t"   (cmd! (org-agenda nil "t"))
      :desc "learning"   :m "l"   (cmd! (org-agenda nil "l"))
      :desc "notes"      :m "n"   (cmd! (org-agenda nil "n"))
      :desc "grid"       :m "g"   (cmd! (org-agenda nil "g")))
#+end_src

*** Roam

Org roam lacks conventient daily capture function, so I add my own here.
#+begin_src emacs-lisp
(defun org-roam-daily-capture (keys &optional goto template)
  (interactive)
  (let ((org-roam-directory (expand-file-name org-roam-dailies-directory org-roam-directory)))
    (org-roam-capture- :goto (when goto '(4))
                       :keys keys
                       :node (org-roam-node-create)
                       :templates org-roam-dailies-capture-templates
                       :props (list :override-default-time (current-time))))
  (when goto (run-hooks 'org-roam-dailies-find-file-hook)))
#+end_src

Set up capture templates.
#+begin_src emacs-lisp
(setq daily-file-format "%<%Y>/%<%B>/%<%Y-%m-%d>.org"
      daily-head-format "#+TITLE: %<%Y-%m-%d>\n#+ROAM_TAGS: daily\n#+STARTUP: showall\n\n* Journal\n* Notes :note:"
      daily-journal-entry `(file+head+olp ,daily-file-format ,daily-head-format ("Journal"))
      daily-note-entry `(file+head+olp ,daily-file-format ,daily-head-format ("Note")))

(after! org-roam
  (setq org-roam-capture-templates
        `(("d" "default" plain
           "%?"
           :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+TITLE: ${title}")
           :unnarrowed t)
          ("b" "book" plain
           (file ,(concat org-templates-dir "book.org"))
           :if-new (file+head "${slug}.org"
                              "#+TITLE: [T] ${title}\n#+AUTHOR: %^{Author}\n#+SOURCE: %^{Source}\n#+FILETAGS: book")
           :unnarrowed t)
          ("c" "course" plain
           (file ,(concat org-templates-dir "course.org"))
           :if-new (file+head "${slug}.org"
                              "#+TITLE: [T] ${title}\n#+AUTHOR: %^{Author}\n#+SOURCE: %^{Source}\n#+FILETAGS: course")
           :unnarrowed t)
          ("p" "project" plain
           (file ,(concat org-templates-dir "project.org"))
           :if-new (file+head "${slug}.org"
                              "#+TITLE: [R] ${title}\n#+FILETAGS: project")
           :unnarrowed t)
        )
        org-roam-dailies-capture-templates
          `(("j" "journal" entry
             "** %<%H:%M> %?"
             :if-new ,daily-journal-entry
             :unnarrowed t)
            ("n" "note" entry
             "** TODO %?"
             :if-new ,daily-note-entry
             :unnarrowed t
             ))))
#+end_src

Refresh agenda files after a node with a tracker tag is created.
#+begin_src emacs-lisp
(defun ma/refresh-agenda-hook ()
  (when (org-roam-capture-p)
    (unless org-note-abort
      (when-let* ((id (org-roam-capture--get :id))
                  (node (org-roam-node-from-id id))
                  (tags (org-roam-node-tags node)))
        (when (seq-intersection tags ma/roam-agenda-tags)
          (push (org-roam-node-file node) org-agenda-files))))))

(add-hook 'org-capture-after-finalize-hook #'ma/refresh-agenda-hook)
#+end_src

Immediate insertion.
#+begin_src emacs-lisp
(defun org-roam-node-insert-immediate (arg &rest args)
  (interactive "P")
  (let ((args (cons arg args))
        (org-roam-capture-templates (list (append (car org-roam-capture-templates)
                                                  '(:immediate-finish t)))))
    (apply #'org-roam-node-insert args)))

(map! :map org-mode-map
      :desc "insert" :g "C-c n I" #'org-roam-node-insert-immediate)
#+end_src

**** Keybindings

Set up C-c n keybindings.
#+begin_src emacs-lisp
(map! :prefix ("C-c n" . "notes")
      :desc "toggle"  :g "t" #'org-roam-buffer-toggle
      :desc "find"    :g "f" #'org-roam-node-find
      :desc "insert"  :g "i" #'org-roam-node-insert
      :desc "capture" :g "c" #'org-roam-capture
      :desc "today"   :g "d" (cmd! (ma/daily-capture "n" t)))
#+end_src

Set up C-c c capture keybindings.
#+begin_src emacs-lisp
(map! :prefix ("C-c c" . "capture")
      :desc "book"       :g "b" (cmd! (org-roam-capture nil "b"))
      :desc "course"     :g "c" (cmd! (org-roam-capture nil "c"))
      :desc "project"    :g "p" (cmd! (org-roam-capture nil "p"))
      :desc "journal"    :g "j" (cmd! (org-roam-daily-capture "j"))
      :desc "note"       :g "n" (cmd! (org-roam-daily-capture "n")))
#+end_src

Set up SPC capture keybindings.
#+begin_src emacs-lisp
(map! :leader
      :prefix ("r c" . "capture")
      :desc "book"       :m "b" (cmd! (org-roam-capture nil "b"))
      :desc "course"     :m "c" (cmd! (org-roam-capture nil "c"))
      :desc "project"    :m "p" (cmd! (org-roam-capture nil "p"))
      :desc "journal"    :m "j" (cmd! (org-roam-daily-capture "j"))
      :desc "note"       :m "n" (cmd! (org-roam-daily-capture "n")))
#+end_src

*** Refiling

Set up general refiling parameters.
#+begin_src emacs-lisp
(setq org-refile-use-outline-path 'file
      org-outline-path-complete-in-steps nil
      org-refile-allow-creating-parent-nodes 'confirm)
#+end_src

Set up refiling paths.
#+begin_src emacs-lisp
(defun ma/refile (target heading &optional arg default-buffer msg)
  "Refile entries with top-level PARENT under the (exact) HEADING in FILE."
  (let* ((position
          (if heading
              (with-current-buffer (find-file-noselect target)
                (or (org-find-exact-headline-in-buffer heading)
                    (org-end-of-subtree t t)))))
         (rfloc `(,heading ,target nil ,position)))
    (org-refile arg default-buffer rfloc msg)))

(defun ma/refile-to-file (file state &optional follow)
  (interactive)
  (org-todo state)
  (org-entry-put (point) "ORDERED" "t")
  (ma/refile file nil)
  (when follow
    (org-refile-goto-last-stored)))

(defun ma/refile-to-habits ()
  "Move the current subtree from processing to a habits."
  (interactive)
  (org-todo "TODO")
  (org-insert-property-drawer)
  (org-entry-put (point) "STYLE" "habit")
  (org-entry-put (point) "LAST_REPEAT" nil)
  (let* ((date (org-read-date))
         (min (read-number "Do the habit no often than this many days: " 1))
         (max (read-number "Do the habit at least once in this many days: " 1))
         (repeat-str
          (if (>= min max)
              (format ".+%dd" min)
              (format ".+%dd/%dd"))))
    (org-schedule nil (message "<%s %s>" date repeat-str))
    (ma/refile org-habits-file nil)))

(defun ma/refile-to-incubator ()
  "Refile the current subtree to the incubator based on top-level non-inherited tag"
  (interactive)
  (org-todo "TODO")
  (if-let ((tags (org-get-tags nil t)))
    (let* ((category (car tags))
           (file-name (format "%s.org" category))
           (file-path (concat org-incubator-dir file-name))
           (header (format "#+FILETAGS: %s\n\n" category)))
      (unless (file-exists-p file-path)
        (append-to-file header nil file-path))
      (org-toggle-tag category 'off)
      (ma/refile file-path nil))
    (ma/refile (concat org-incubator-dir "incubator.org"))))

(defun ma/refile-to-list ()
  "Refile the current subtree to the shopping list based on top-level non-inherited tag"
  (interactive)
  (org-todo "TODO")
  (if-let ((tags (org-get-tags nil t)))
    (let* ((category-tag (car tags))
           (category (capitalize category-tag)))
      (org-toggle-tag category-tag 'off)
      (ma/refile org-list-file category))))
#+end_src

Set up refiling keybindings.
#+begin_src emacs-lisp
(map! :map org-mode-map :leader
      :prefix ("r r" . "refile")
      :desc "refile"     :n "/" #'org-refile
      :desc "task"       :n "t" (cmd! (ma/refile-to-file org-tasks-file "NEXT"))
      :desc "event"      :n "e" (cmd! (ma/refile-to-file org-events-file "TODO"))
      :desc "list"       :n "l" #'ma/refile-to-list
      :desc "habits"     :n "h" #'ma/refile-to-habits
      :desc "incubate"   :n "i" #'ma/refile-to-incubator)
#+end_src

Save org buffers after refiling.
#+begin_src emacs-lisp
(advice-add 'org-refile :after (lambda (&rest _) (org-save-all-org-buffers)))
#+end_src

*** Capture

Set up capture templates.
#+begin_src emacs-lisp
(setq org-capture-templates
  '(("x" "inbox`" entry (file org-inbox-file) "* %?" :prepend t :kill-buffer t :empty-lines-before 1)))
#+end_src

Set up keybindings
#+begin_src emacs-lisp
(map! :prefix ("C-c c" . "capture")
      :desc "inbox"      :g "x" (cmd! (org-capture nil "x")))

(map! :leader
      :prefix ("r c" . "capture")
      :desc "inbox"      :m "x" (cmd! (org-capture nil "x")))
#+end_src
*** Clocking

Clocking setup
#+begin_src emacs-lisp
(after! org
  (setq org-clock-out-when-done t
        org-clock-persist 'history))
#+end_src

Clock out function should check that we are in the correct state first.
#+begin_src emacs-lisp
(defun ma/clock-out ()
  (interactive)
  (when (equal (org-get-todo-state) "NEXT")
    (org-clock-out)))

(defun ma/agenda-clock-out ()
  (interactive)
  (let* ((marker (or (org-get-at-bol 'org-marker) (org-agenda-error)))
         (pos (marker-position marker))
         (buffer (marker-buffer marker)))
    (org-with-remote-undo buffer
      (with-current-buffer buffer
        (goto-char pos)
        (call-interactively 'ma/clock-out)))))
#+end_src

Set up a hook to save clocked time to dailies
#+begin_src emacs-lisp
(defun ma/agenda-get-heading (&optional NO-TAGS NO-TODO NO-PRIORITY NO-COMMENT)
  (let* ((marker (or (org-get-at-bol 'org-marker) (org-agenda-error)))
         (pos (marker-position marker))
         (buffer (marker-buffer marker)))
    (with-current-buffer buffer
      (goto-char pos)
      (org-get-heading NO-TAGS NO-TODO NO-PRIORITY NO-COMMENT))))

(defun ma/clock-out-handler ()
  (let* ((start-time (format-time-string "%H:%M" org-clock-start-time))
         (end-time (format-time-string "%H:%M" org-clock-out-time))
         (heading (if (equal major-mode 'org-agenda-mode)
                      (ma/agenda-get-heading t t t t)
                    (org-get-heading t t t t)))
         (entry (format "** %s - %s %s" start-time end-time heading)))
    (org-roam-capture- :node (org-roam-node-create)
                       :templates `(("j" "journal" plain ,entry
                                     :if-new ,daily-journal-entry
                                     :immediate-finish t)))))

(after! org
  (add-hook 'org-clock-out-hook (todo-completion! 'ma/clock-out-handler)))
#+end_src
